<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Chanko Module: chanko/operations</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.dark.css">

	<link type="text/css" rel="stylesheet" href="styles/site.slate.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">Chanko</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-chanko_channels.html">chanko/channels</a></li><li><a href="module-chanko_operations.html">chanko/operations</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-8">
	
		<div id="main">
			

	<h1 class="page-title">Module: chanko/operations</h1>
<section>

<header>
    
</header>


<article>
    <div class="container-overview">
    
        
            <div class="description"><p>A set of utility functions that give one or more channels some extra
functionality. Each of these accept one or more
<a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a> objects and then combine or manipulate
them in (hopefully) useful ways, such as merging them, splitting them,
reducing values they receive to a single value, or throttling them so that
they only produce one result in a given time period.</p></div>
        

        
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_index.js.html">operations/src/index.js</a>,
				 <a href="operations_src_index.js.html#sunlight-1-line-8">line 8</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


        
    
    </div>

    

    

    

    

    

    

    
        <h3 class="subsection-title">Methods</h3>

        <dl>
            
<hr>
<dt>
    <h4 class="name" id=".debounce"><span class="type-signature">&lt;static> </span>debounce(src [, buffer], delay [, options])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Debounces an input channel.</p>
<p>Debouncing is the act of turning several input values into one. For example,
debouncing a channel driven by a <code>mousemove</code> event would cause only the final
<code>mousemove</code> event to be put onto the channel, dropping all of the other ones.
This can be desirable because <code>mousemove</code> events come in bunches, being
produced continually while the mouse is moving, and often all that we really
care about is to learn where the mouse ended up.</p>
<p>This function does this by controlling which values that have been sent to
the source channel are made available on the destination channel, and when.</p>
<p>The <code>delay</code> parameter determines the debounce threshold. Once the first value
is sent to the source channel, debouncing is in effect until the number of
milliseconds in <code>delay</code> passes without any other value being put onto that
channel. In other words, the delay will be refreshed if another value is sent
to the source channel before the delay elapses. After a full delay interval
passes without a value being sent to the source channel, the last value sent
becomes available on the destination channel.</p>
<p>This behavior can be modified through four options: <code>leading</code>, <code>trailing</code>,
<code>maxDelay</code>, and <code>cancel</code>.</p>
<p>If both <code>leading</code> and <code>trailing</code> are <code>true</code>, values will not be duplicated.
The first value put onto the source channel will be put onto the destination
channel immediately (per <code>leading</code>) and the delay will begin, but a value
will only be made available on the destination channel at the end of the
delay (per <code>trailing</code>) if <em>another</em> input value was put onto the source
channel before the delay expired.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>buffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">FixedBuffer</a> of that size will be
used. If this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>delay</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The debouncing delay, in milliseconds.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>options</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    {}
                
                </td>
            

            <td class="description last"><p>A set of options to further configure the
debouncing.</p>
                <h6 class="method-params-label method-subparams-label">Properties</h6>
                

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>leading</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>Instead of making a value available
on the destination channel after the delay passes, the first value put
onto the source channel is made available <em>before</em> the delay begins. No
value is available on the destination channel after the delay has elapsed
(unless <code>trailing</code> is also <code>true</code>).</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>trailing</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last"><p>The default behavior, where a value
is not made available on the destination channel until the entire delay
passes without a new value being put on the source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>maxDelay</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>The maximum delay allowed before a value
is put onto the destination channel. Debouncing can, in theory, go on
forever as long as new input values continue to be put onto the source
channel before the delay expires. Setting this option to a positive
number sets the maximum number of milliseconds that debouncing can go on
before it's forced to end, even if in the middle of a debouncing delay.
Having debouncing end through the max delay operates exactly as if it had
ended because of lack of input; the last input is made available on the
destination channel (if <code>trailing</code> is <code>true</code>), and the next input will
trigger another debounce operation.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cancel</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A channel used to
signal a cancellation of the debouncing. Any value put onto this channel
will cancel the current debouncing operation, closing the output channel
and discarding any values that were waiting for the debounce threshold
timer to be sent to the output.</p></td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_timing.js.html">operations/src/modules/timing.js</a>,
				 <a href="operations_src_modules_timing.js.html#sunlight-1-line-96">line 96</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>The newly-created destination
channel, where all of the values will be debounced from the source
channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".map"><span class="type-signature">&lt;static> </span>map(fn, srcs [, buffer])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Maps the values from one or more source channels through a function, sending
the results to a new channel.</p>
<p>The mapping function is given one value from each source channel, after at
least one value becomes available on every source channel. The output value
from the function is then sent to the destination channel.</p>
<p>The destination channel is created by the function based on the buffer value
passed as the third parameter. If this is missing, <code>null</code>, or <code>0</code>, the
destination channel will be unbuffered. If it's a positive integer, the
destination channel is buffered by a fixed buffer of that size. If the
parameter is a buffer, then that buffer is used to buffer the destination
channel.</p>
<p>Once <em>any</em> source channel is closed, the mapping ceases and the destination
channel is also closed.</p>
<p>This is obviously similar to a map transducer, but unlike a transducer, this
function works with multiple input channels. This is something that a
transducer on a single channel is unable to do.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv, close, isClosed } from &quot;@chanko/channels&quot;;
import { map } from &quot;@chanko/operations&quot;

const input1 = chan();
const input2 = chan();
const input3 = chan();
const output = map((x, y, z) => x + y + z, [input1, input2, input3]);

go(async () => {
  await send(input1, 1);
  await send(input1, 2);
  await send(input1, 3);
});

go(async () => {
  await send(input2, 10);
  await send(input2, 20);
  close(input2);
});

go(async () => {
  await send(input3, 100);
  await send(input3, 200);
  await send(input3, 300);
});

go(async () => {
  console.log(await recv(output));     // -> 111
  console.log(await recv(output));     // -> 222
  // Output closes now because input2 closes after 2 values
  console.log(isClosed(output));       // -> true
});
</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_operations.html#.Mapper">module:chanko/operations.Mapper</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The mapping function. This should
have one parameter for each source channel and return a single value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>srcs</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array.&lt;<a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a>></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channels.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>buffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">module:chanko/channels.FixedBuffer</a> of that size will be used. If
this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-595">line 595</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>The destination channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".merge"><span class="type-signature">&lt;static> </span>merge(srcs [, buffer])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Merges one or more channels into a single destination channel.</p>
<p>Values are given to the destination channel as they are sent to the source
channels. If <code>merge</code> is called when there are already values on multiple
source channels, the order that they're put onto the destination channel is
random.</p>
<p>The destination channel is created by the function based on the buffer value
passed as the second parameter. If this is missing, <code>null</code>, or <code>0</code>, the
destination channel will be unbuffered. If it's a positive integer, the
destination channel is buffered by a fixed buffer of that size. If the
parameter is a buffer, then that buffer is used to buffer the destination
channel.</p>
<p>As each source channel closes, it is removed from the merge, leaving the
channels that are still open to continue merging. When <em>all</em> of the source
channels close, then the destination channel is closed.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv } from &quot;@chanko/channels&quot;;
import { merge } from &quot;@chanko/operations&quot;;

const input1 = chan();
const input2 = chan();
const input3 = chan();
const output = merge([input1, input2, input3]);

go(async () => {
  // Because we're sending to all three channels in the same
  // process, we know the order in which the values will be
  // sent to the output channel; in general, we won't know this
  await send(input1, 1);
  await send(input2, 2);
  await send(input3, 3);
});

go(async () => {
  console.log(await recv(output));      // -> 1
  console.log(await recv(output));      // -> 2
  console.log(await recv(output));      // -> 3
});
</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>srcs</code></td>
            

            <td class="type">
            
                
<span class="param-type">Array.&lt;<a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a>></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>An array of source channels.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>buffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">module:chanko/channels.FixedBuffer</a> of that size will be used. If
this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-259">line 259</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>The destination channel, which will
receive all values put onto every source channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".partition"><span class="type-signature">&lt;static> </span>partition(fn, src [, tBuffer] [, fBuffer])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Creates two new channels and routes values from a source channel to them
according to a predicate function.</p>
<p>The supplied function is invoked with every value that is put onto the source
channel. Those that return <code>true</code> are routed to the first destination
channel; those that return <code>false</code> are routed to the second.</p>
<p>The new channels are created by the function based on the buffer values
passed as the third and fourth parameters. If one or both of these are
missing, <code>null</code>, or <code>0</code>, the corresponding destination channel is unbuffered.
If one is a positive integer, the corresponding channel is buffered by a
fixed buffer of that size. If the parameter for a channel is a buffer, then
that buffer is used to buffer the new channel.</p>
<p>Both new channels are closed when the source channel is closed.</p>
<pre class="prettyprint source"><code>import { go, chan, send, close } from &quot;@chanko/channels&quot;;
import { partition } from &quot;@chanko/operations&quot;;

const input = chan();
const ctrl = chan();
const [even, odd] = partition(x => x % 2 === 0, input, 3, 3);

go(async () => {
  await send(input, 1);
  await send(input, 2);
  await send(input, 3);
  await send(input, 4);
  close(input);
});

go(async () => {
  for await (const value of even) {
    console.log(value);
  }
  await send(ctrl);
});

go(async () => {
  await recv(ctrl);
  for await (const value of odd) {
    console.log(value);
  }
});

// The `ctrl` channel ensures that all of the values on the even channel are
// read before any of the values on the odd channel are (this is only
// possible because the output channels have buffers big enough to make sure
// that no send is blocked).
//
// -> 2
// -> 4
// -> 1
// -> 3
</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_operations.html#.Predicate">module:chanko/operations.Predicate</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A predicate function used to
test each value on the input channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>tBuffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel which receives all values that passed the
predicate. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">module:chanko/channels.FixedBuffer</a> of that size will be used. If
this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>fBuffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel which receives all values that did not
pass the predicate. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">module:chanko/channels.FixedBuffer</a> of that size will be used. If
this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-187">line 187</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>An array of two channels. The first
is the destination channel with all of the values that passed the
predicate, the second is the destination channel with all of the values
that did not pass the predicate.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array.&lt;<a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a>></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".pipe"><span class="type-signature">&lt;static> </span>pipe(src, dest [, keepOpen])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Pipes the values from one channel to another channel.</p>
<p>This ties two channels together so that puts on the source channel can be
taken off the destination channel. This does not duplicate values in any way;
if another process takes a value off the source channel, it will never appear
on the destination channel. In most cases you will not want to take values
off a channel once it's piped to another channel, since it's difficult to
know which values will go to which channel.</p>
<p>Closing either channel will break the connection between the two. If the
source channel is closed, the destination channel will by default also be
closed. However, passing <code>true</code> as the third parameter will cause the
destination channel to remain open even when the source channel is closed
(the connection is still broken however).</p>
<p>Because of the ability to leave the destination channel open, a possible use
case for this function is to wrap the destination channel(s) of one of the
other flow control functions below to have a channel that survives the source
channel closing. The rest of those functions (aside from the special-case
<code><a href="module-chanko_operations.html#.tap">tap</a></code>) automatically close their
destination channels when the source channels close.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv, close, isClosed } from &quot;@chanko/channels&quot;;
import { pipe } from &quot;@chanko/operations&quot;;

const input = chan();
const output = pipe(input, chan());

go(async () => {
  await send(input, 1);
  await send(input, 2);
  close(input);
});

go(async () => {
  console.log(await recv(output));      // -> 1
  console.log(await recv(output));      // -> 2
  console.log(isClosed(output));        // -> true
});
</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>dest</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The destination channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>keepOpen</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    false
                
                </td>
            

            <td class="description last"><p>A flag to indicate that the destination
channel should be kept open after the source channel closes. By default
the destination channel will close when the source channel closes.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-90">line 90</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>The destination channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".reduce"><span class="type-signature">&lt;static> </span>reduce(fn, channel, init)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Creates a single value from a channel by running its values through a
reducing function.</p>
<p>For every value put onto the input channel, the reducing function is called
with two parameters: the accumulator that holds the result of the reduction
so far, and the new input value. The initial value of the accumulator is the
third parameter to <code>reduce</code>. The reduction is not complete until the input
channel closes.</p>
<p>This function returns a channel. When the final reduced value is produced, it
is put onto this channel, and when that value is taken from it, the channel
is closed.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv, close } from &quot;@chanko/channels&quot;;
import { reduce } from &quot;@chanko/operations&quot;;

const input = chan();
const output = reduce((acc, value) => acc + value, input, 0);

go(async () => {
  await send(input, 1);
  await send(input, 2);
  await send(input, 3);
  close(input);
});

go(async () => {
  const result = await recv(output);
  console.log(output);                  // -> 6
});

</code></pre>
<p>Note that the input channel <em>must</em> be closed at some point, or no value will
ever appear on the output channel. The closing of the channel is what
signifies that the reduction should be completed.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_operations.html#.Reducer">module:chanko/operations.Reducer</a></span>



            
            </td>

            

            

            <td class="description last"><p>The reducer function responsible
for turning the series of channel values into a single output value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>channel</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            

            

            <td class="description last"><p>The channel whose values are
being reduced into a single output value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>init</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>



            
            </td>

            

            

            <td class="description last"><p>The initial value to feed into the reducer function for the
first reduction step.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_conversion.js.html">operations/src/modules/conversion.js</a>,
				 <a href="operations_src_modules_conversion.js.html#sunlight-1-line-68">line 68</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>A channel that will, when the input
channel closes, have the reduced value put into it. When this value is
taken, the channel will automatically close.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".split"><span class="type-signature">&lt;static> </span>split(src [, buffers])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Splits a single channel into multiple destination channels, with each
destination channel receiving every value sent to the source channel.</p>
<p>Every parameter after the first represents the buffer from a single
destination channel. Each <code>0</code> or <code>null</code> will produce an unbuffered channel,
while each positive integer will produce a channel buffered by a fixed buffer
of that size. Each buffer will produce a buffered channel backed by that
buffer. If there are no parameters after the first, then two unbuffered
channels will be produced as a default.</p>
<p>When the source channel is closed, all destination channels will also be
closed. However, if destination channels are closed, they do nothing to the
source channel.</p>
<pre class="prettyprint source"><code>import { go, chan, send } from &quot;@chanko/channels&quot;;
import { split } from &quot;@chanko/operations&quot;;

const input = chan();
const outputs = split(input, 3);

go(async () => {
  await send(input, 1);
  await send(input, 2);
  await send(input, 3);
});

go(async () => {
  for await (const output of outputs) {
    console.log(output);
    // -> 1
    // -> 2
    // -> 3
  }
});
</code></pre>
<p>This function moves its values to the output channels asynchronously. This
means that even when using unbuffered channels, it is not necessary for all
output channels to be received from before the next send to the input channel
can complete.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>buffers</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            
                <td class="default">
                
                    2
                
                </td>
            

            <td class="description last"><p>The buffers
used to create the destination channels. Each entry is treated
separately. If one is a number, then a
<a href="module-chanko_channels.html#.FixedBuffer">FixedBuffer</a> of that size will
be used. If one is a <code>0</code>, then the corresponding channel will be
unbuffered. <strong>Exception:</strong> if a single number is passed, then that number
of unbuferred channels will be created. This means that the default is to
create two unbuffered channels. To create a single channel with a fixed
buffer, use <code>fixed</code> explicitly.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-337">line 337</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>An array of destination channels.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">Array.&lt;<a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a>></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".tap"><span class="type-signature">&lt;static> </span>tap(src [, dest])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Taps a channel, sending all of the values sent to it to the destination
channel.</p>
<p>A source channel can be tapped multiple times, and all of the tapping
(destination) channels receive each value sent to the tapped (source)
channel.</p>
<p>This is different from <code><a href="module-chanko_operations.html#.split">split</a></code> in that
it's temporary. Channels can tap a channel and then untap it, multiple times,
as needed. If a source channel has all of its taps removed, then it reverts
to a normal channel, just as it was before it was tapped.</p>
<p>Also unlike <code><a href="module-chanko_operations.html#.split">split</a></code>, each call can
only tap once. For multiple channels to tap a source channel, <code>tap</code> has to be
called multiple times.</p>
<p>Closing either the source or any of the destination channels has no effect on
any of the other channels.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv } from &quot;@chanko/channels&quot;;
import { tap } from &quot;@chanko/operations&quot;;

const input = chan();
const tapper = chan();
tap(input, tapper);

go(async () => {
  await send(input, 1);
  await send(input, 2);
});

go(async () => {
  console.log(await recv(tapper));   // -> 1
  console.log(await recv(tapper));   // -> 2
});

</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The channel to be tapped.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>dest</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last"><p>The channel tapping the source
channel. If this is not present, a new unbuffered channel will be
created.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-471">line 471</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>The destination channel. This is the
same as the second argument, if present; otherwise it is the
newly-created channel tapping the source channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".throttle"><span class="type-signature">&lt;static> </span>throttle(src [, buffer], delay [, options])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Throttles an input channel.</p>
<p>Throttling is the act of ensuring that something only happens once per time
interval. In this case, it means that a value sent to the source channel is
only made available to the destination channel once per a given number of
milliseconds. An example usage would be with window scroll events; these
events are nearly continuous as scrolling is happening, and perhaps we don't
want to call an expensive UI updating function every time a scroll event is
fired. We can throttle the input channel and make it only offer up the scroll
events once every 100 milliseconds, for instance.</p>
<p>Throttling is effected by creating a new channel as a throttled destination
for values sent to the source channel. Values will only appear on that
destination channel once per delay interval; other values that are put onto
the source channel in the meantime are discarded.</p>
<p>The <code>delay</code> parameter controls how often a value can become available on the
destination channel. When the first value is sent to the source channel, it
is immediately sent to the destination channel as well and the delay begins.
Any further values sent to the source channel during that delay are <em>not</em>
passed through; only when the delay expires is the last input value made
available on the destination channel. The delay then begins again, so that
further inputs are squelched until <em>that</em> delay passes. Throttling continues,
only allowing one value through per interval, until an entire interval passes
without input.</p>
<p>This behavior can be modified by three options: <code>leading</code>, <code>trailing</code>, and
<code>cancel</code>.</p>
<p>If both <code>leading</code> and <code>trailing</code> are <code>true</code>, values will not be duplicated.
The first value sent to the source channel will be put onto the destination
channel immediately (per <code>leading</code>) and the delay will begin, but a value
will only be made available on the destination channel at the end of the
delay (per <code>trailing</code>) if <em>another</em> input value was sent to the source
channel before the delay expired.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The source channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>buffer</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>
|

<span class="param-type"><a href="module-chanko_channels.html#.Buffer">module:chanko/channels.Buffer</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    0
                
                </td>
            

            <td class="description last"><p>A buffer used to
create the destination channel. If this is a number, a
<a href="module-chanko_channels.html#.FixedBuffer">FixedBuffer</a> of that size will
be used. If this is <code>0</code> or not present, the channel will be unbuffered.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>delay</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>The throttling delay, in milliseconds.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>options</code></td>
            

            <td class="type">
            
                
<span class="param-type">Object</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    {}
                
                </td>
            

            <td class="description last"><p>A set of options to further configure the
throttling.</p>
                <h6 class="method-params-label method-subparams-label">Properties</h6>
                

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        
        <th>Default</th>
        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>leading</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last"><p>Makes the value that triggered the
throttling immediately available on the destination channel before
beginning the delay. If this is <code>false</code>, the first value will not be put
onto the destination channel until a full delay interval passes.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>trailing</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                    true
                
                </td>
            

            <td class="description last"><p>Makes the last value put onto the
source channel available on the destination channel when the delay
expires. If this is <code>false</code>, any inputs that come in during the delay are
ignored, and the next value is not put onto the destination channel until
the first input <em>after</em> the delay expires.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cancel</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            
                <td class="default">
                
                </td>
            

            <td class="description last"><p>A channel used to
signal a cancellation of the throttling. Any value put onto this channel
will cancel the current throttling operation, closing the output channel
and discarding any values that were waiting for the throttle threshold
timer to be sent to the output.</p></td>
        </tr>

    
    </tbody>
</table>

            </td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_timing.js.html">operations/src/modules/timing.js</a>,
				 <a href="operations_src_modules_timing.js.html#sunlight-1-line-222">line 222</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>} The newly-created destination
channel, where all of the values will be throttled from the source
channel.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".toArray"><span class="type-signature">&lt;static> </span>toArray(channel [, array])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Receives all of the values from a channel and pushes them into an array.</p>
<p>If no array is passed to this function, a new (empty) one is created. In
effect, this directly converts a channel into an array with the same values.
Either way, this operation cannot complete until the input channel is closed.</p>
<p>This function returns a channel. When the final array is produced, it is sent
to this channel, and when that value is received from it, the channel is
closed.</p>
<pre class="prettyprint source"><code>import { go, chan, send, recv, close } from &quot;@chanko/channels&quot;;
import { toArray } from &quot;@chanko/operations&quot;;

const input = chan();
const output = toArray(input);

go(async () => {
  await send(input, 1);
  await send(input, 2);
  await send(input, 3);
  close(input);
});

go(async () => {
  const result = await recv(output);
  console.log(result);                     // -> [1, 2, 3]
});
</code></pre>
<p>Note that the input channel <em>must</em> be closed at some point, or no value will
ever appear on the output channel. The closing of the channel is what
signifies that all of the values needed to make the array are now available.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>channel</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The channel from which values
are received to put into the array.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>array</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last"><p>The array to put the channel values into. If this is
not present, a new, empty array will be created.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_conversion.js.html">operations/src/modules/conversion.js</a>,
				 <a href="operations_src_modules_conversion.js.html#sunlight-1-line-176">line 176</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>A channel that will, when the input
channel closes, have the array of channel values put onto it. When this
array is received, the channel will automatically close.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".toChannel"><span class="type-signature">&lt;static> </span>toChannel(iterable [, channel])</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Sends all values from an iterable to the supplied channel.</p>
<p>If no channel is passed to this function, a new channel is created. In
effect, this directly converts an iterable into a channel with the same
values on it.</p>
<p>The channel is closed after the final iterable value is sent to it.</p>
<p>This function will convert any JavaScript object that implements the iterable
protocol. In other words, if it works in a <code>for...of</code> statement, it will work
here.</p>
<pre class="prettyprint source"><code>import { go, chan, recv, isClosed } from &quot;@chanko/channels&quot;;
import { toChannel } from &quot;@chanko/operations&quot;;

const input = [1, 2, 3];
const output = toChannel(input);

go(async () => {
  console.log(await recv(output));     // -> 1
  console.log(await recv(output));     // -> 2
  console.log(await recv(output));     // -> 3
  console.log(isClosed(output));       // -> true
});
</code></pre>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>iterable</code></td>
            

            <td class="type">
            
                
<span class="param-type">iterable</span>



            
            </td>

            
                <td class="attributes">
                

                

                
                </td>
            

            

            <td class="description last"><p>The iterable containing the values to be sent to
the channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>channel</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            
                <td class="attributes">
                
                    &lt;optional><br>
                

                

                
                </td>
            

            

            <td class="description last"><p>The channel onto which to
put all of the array elements. If this is not present, a new channel will
be created.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_conversion.js.html">operations/src/modules/conversion.js</a>,
				 <a href="operations_src_modules_conversion.js.html#sunlight-1-line-121">line 121</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>the channel onto which the array
elements are put. This is the same as the input channel, but if no input
channel is specified, this will be a new channel. It will close when the
final value is taken from it.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



    </dd>
</dl>


        

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".untap"><span class="type-signature">&lt;static> </span>untap(src, dest)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Untaps a previously tapping destination channel from its source channel.</p>
<p>This removes a previously created tap. The destination (tapping) channel will
stop receiving the values sent to the source channel.</p>
<p>If the destination channel was not, in fact, tapping the source channel, this
function will do nothing. If all taps are removed, the source channel reverts
to normal (i.e., it no longer has the tapping code applied to it and can be
taken from as normal).</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            

            

            <td class="description last"><p>The tapped channel.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>dest</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            

            

            <td class="description last"><p>The channel that is tapping the
source channel that should no longer be tapping the source channel.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-497">line 497</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    

    
</dd>

        
            
<hr>
<dt>
    <h4 class="name" id=".untapAll"><span class="type-signature">&lt;static> </span>untapAll(src)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>Removes all taps from a source channel.</p>
<p>The previously-tapped channel reverts to a normal channel, while any channels
that might have been tapping it no longer receive values from the source
channel. If the source channel had no taps, this function does nothing.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>src</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-chanko_channels.html#.Channel">module:chanko/channels.Channel</a></span>



            
            </td>

            

            

            <td class="description last"><p>The tapped channel. All taps will
be removed from this channel.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_modules_flow.js.html">operations/src/modules/flow.js</a>,
				 <a href="operations_src_modules_flow.js.html#sunlight-1-line-521">line 521</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    

    
</dd>

        </dl>
    

    
        <h3 class="subsection-title">Type Definitions</h3>

        <dl>
                
<hr>
<dt>
    <h4 class="name" id=".Mapper"><span class="type-signature"></span>Mapper(values)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>A function that maps its input(s) to an output value. It takes a variable
number of input values and calculates an output value from them.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        
        <th>Argument</th>
        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>values</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>



            
            </td>

            
                <td class="attributes">
                

                

                
                    &lt;repeatable><br>
                
                </td>
            

            

            <td class="description last"><p>The input values.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_index.js.html">operations/src/index.js</a>,
				 <a href="operations_src_index.js.html#sunlight-1-line-43">line 43</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>An output value calculated from the input values.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>



    </dd>
</dl>


        

    
</dd>

            
                
<hr>
<dt>
    <h4 class="name" id=".Predicate"><span class="type-signature"></span>Predicate(value)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>A function that takes a single value and, depending on whether that value
meets the function's criteria for passing, returns <code>true</code> or <code>false</code>.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>



            
            </td>

            

            

            <td class="description last"><p>The value to test. Whether or not the value passes the test
depends on the criteria established by the predicate.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_index.js.html">operations/src/index.js</a>,
				 <a href="operations_src_index.js.html#sunlight-1-line-32">line 32</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>Either <code>true</code> if the value passes or <code>false</code> if it doesn't.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>



    </dd>
</dl>


        

    
</dd>

            
                
<hr>
<dt>
    <h4 class="name" id=".Reducer"><span class="type-signature"></span>Reducer(acc, value)</h4>
    
    
</dt>
<dd>

    
    <div class="description">
        <p>A function that integrates one of its values into the other. It's used for
reducing channel values into a single value.</p>
    </div>
    

    

    

    
    
        <h5>Parameters:</h5>
        

<table class="params table table-striped">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>acc</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>



            
            </td>

            

            

            <td class="description last"><p>The current accumulated value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>



            
            </td>

            

            

            <td class="description last"><p>The new value that needs to be integrated into the
accumulated value.</p></td>
        </tr>

    
    </tbody>
</table>

    

    
<dl class="details">
    

	

	

	

    

    

    

    

	

	

	

	

	



	
	<dt class="tag-source method-doc-label method-doc-details-label">Source:</dt>
	<dd class="tag-source">
		<ul class="dummy">
			<li>
				<a href="operations_src_index.js.html">operations/src/index.js</a>,
				 <a href="operations_src_index.js.html#sunlight-1-line-53">line 53</a>
			</li>
		</ul>
	</dd>
	

	

	

	
</dl>


    

    

    

    

    

    
    <h5>Returns:</h5>
    
            
<div class="param-desc">
    <p>A new accumulated value, resulting from integrating <code>value</code> into
the original accumulated value.</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>



    </dd>
</dl>


        

    
</dd>

            </dl>
    

    
</article>

</section>




		</div>
	</div>

	<div class="clearfix"></div>

	
		<div class="col-md-3">
			<div id="toc" class="col-md-3 hidden-xs hidden-sm hidden-md"></div>
		</div>
	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	&copy; Copyright 2020, Thomas J. Otterson. All rights reserved.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>