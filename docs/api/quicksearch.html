<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"channels_src_index.js.html":{"id":"channels_src_index.js.html","title":"Source: channels/src/index.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/index.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * All of the public-facing Chanko functions are gathered here in one place to * be exported as a whole. This is a completely flat list of exports, as * inluding any object literals for export (which would be natural for buffers, * for example) would keep tree-shaking from working right. * * @module chanko/channels */ export { fixed, dropping, sliding } from \"modules/buffer\"; export { CLOSED, chan, timedChan, transChan, send, recv, sendAsync, recvAsync, recvOrThrow, close, isClosed, isBuffered, isTimed, select, selectAsync, value, channel } from \"modules/channel\"; export { config, SET_IMMEDIATE, MESSAGE_CHANNEL, SET_TIMEOUT } from \"modules/dispatcher\"; export { go, sleep, join } from \"modules/process\"; export { EMPTY } from \"modules/queue\"; /** * An error handling funciton. This is used to handle exceptions thrown in async * functions and in transducers. The return value of an exception handler is * typically sent to a channel; if the exception happened within an async * function, it will be sent to that function's output channel, and if the * excpetion happened in a transducer, it will be sent to the channel to which * the transducer is attached. * * @callback ExceptionHandler * @memberof module:chanko/channels * @param {object} err The error object that was thrown to cause the error to * have to be handled. * @return {*} A value decided by the handler that will be sent to a channel. */ /** * A callback that's run when a non-blocking channel operation completes. The * value that this function receives is identical to what is returned by a * blocking call: the value received from the channel for a `recv`, or `true` or * `false` depending on the channel status for a `send`. Any return value from * this callback is ignored. * * @callback OpCallback * @memberof module:chanko/channels * @param {*} value Either the value received from the channel, or whether or * not a value was successfully sent. */ /** * A callback that's run when a non-blocking `select` operation completes. The * value that this function receives is an object with two properties: the value * that the `select` operation completed with (either the value received from * the channel in a receive operation, or `true` or `false` in a send * operation), along with the channel where the operation actually happened. Any * return value from this callback is ignored. * * @callback SelectCallback * @memberof module:chanko/channels * @param {module:chanko/channels.SelectResult} data The value returned from the * select operation. */ /** * A function that transforms data and can be composed with other transducers * into a single transducer. The transducers themselves are provided by other * libraries; the only involvement of this librar is as a consumer of * transducers. * * Transducers work by having step functions that are known via protocol, and it * is these step functions that take a value at a time to be transformed as * their arguments. The arguments to the transducers themselves are other * transducers that are then composed into a single transducer, which is then * returned. These values need not concern a user of ths library; just pass a * transducer to `{@link module:chanko/channels.chan|chan}` or * `{@link module:chanko/channels.transChan|transChan}` and everything else will * be handled. * * @callback Transducer * @memberof module:chanko/channels * @param {module:chanko/channels.Transducer} xform A transducer to chain this * transducer to. * @return {module:chanko/channels.Transducer} A new transducer consisting of * the composition of this one and `xform`. */ × Search results Close "},"channels_src_modules_buffer.js.html":{"id":"channels_src_modules_buffer.js.html","title":"Source: channels/src/modules/buffer.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/buffer.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * Provides several types of buffers usable in buffered channels. These are all * built on a small, efficient queue which is in turn backed by a JavaScript * array. * * @module chanko/buffer * @private */ import { queue as q, count as qCount, enqueue, dequeue } from \"modules/queue\"; /** * A buffer that stores values sent to a buffered channel until a process * receives them. * * Different buffer differ only in the way that they determine whether they are * full and in what happens when a new value is added to a full buffer. * * @memberof module:chanko/channels * @typedef {(module:chanko/channels.FixedBuffer | * module:chanko/channels.DroppingBuffer | * module:chanko/channels.SlidingBuffer)} Buffer */ /** * The name of a property that exists on buffer objects for the purpose of * itentifying them as buffer objects. * * @type {Symbol} * @private */ const BUFFER = Symbol(\"BUFFER\"); /** * A possible value of the `{@link module:chanko/buffer~BUFFER|BUFFER} property * indicating that the buffer is a fixed buffer. * * @type {Symbol} * @private */ const FIXED = Symbol(\"FIXED\"); /** * A possible value of the `{@link module:chanko/buffer~BUFFER|BUFFER} property * indicating that the buffer is a dropping buffer. * * @type {Symbol} * @private */ const DROPPING = Symbol(\"DROPPING\"); /** * A possible value of the `{@link module:chanko/buffer~BUFFER|BUFFER} property * indicating that the buffer is a sliding buffer. * * @type {Symbol} * @private */ const SLIDING = Symbol(\"SLIDING\"); /** * Predicate indicating whether the supplied object is a buffer. * * @param {*} obj The value to test to see if it's a buffer. * @return {boolean} Either `true` if the value is a buffer, or `false` if it is * not. * @private */ function isBuffer(obj) { return !!obj?.[BUFFER]; } /** * A buffer implementation that never discards buffered items when a new item is * added. * * This buffer has a concept of *full*, but it's a soft limit. If the size of * the buffer is exceeded, added items are still stored. * * @typedef FixedBuffer * @memberof module:chanko/channels */ /** * Creates a fixed buffer of the specified capacity. * * A fixed buffer is a 'normal' buffer, one that stores and returns items on * demand. While it is capable of being over-filled, that ability is not used in * Chanko. A buffer that is full will cause the next put to its channel to block * until at least one item is removed from the buffer. * * This buffer is passed to `{@link module:chanko/channels.chan|chan}`, etc. to * create a buffered channel. It is not meant to be used directly. * * @memberof module:chanko/channels * @param {number} size The number of items that the new buffer can hold before * it's full. * @return {module:chanko/channels.FixedBuffer} A new fixed buffer of the * specified capacity. */ function fixed(size) { return Object.create(null, { /** * The queue backing this buffer. * * @type {module:chanko/queue~Queue} * @private * @instance */ queue: { value: q() }, /** * The number of items that this queue can hold before it's considered full. * * @type {number} * @private * @instance */ size: { value: size }, /** * A marker property used to show that this is a fixed buffer. * * @type {Symbol} * @private * @instance */ [BUFFER]: { value: FIXED } }); } /** * A buffer implementation that drops newly added items when the buffer is full. * * This dropping behavior is silent: the new item is simply not added to the * queue. Note that this buffer is never `full` because it can always be added * to without exceeding the size, even if that 'adding' doesn't result in a new * item actually appearing in the buffer. * * @typedef DroppingBuffer * @memberof module:chanko/channels */ /** * Creates a dropping buffer of the specified capacity. * * A dropping buffer silently drops the item being added if the buffer is * already at capacity. Since adding a new item will always 'succeed' (even if * it succeeds by just ignoring the add), it is never considered full and * therefore a put to a channel buffered by a dropping buffer never blocks. * * This buffer is passed to `{@link module:chanko/channels.chan|chan}`, etc. to * create a buffered channel. It is not meant to be used directly. * * @memberof module:chanko/channels * @param {number} size The number of items that the new buffer can hold before * newest items are dropped on add. * @return {module:chanko/channels.DroppingBuffer} A new dropping buffer of the * specified capacity. */ function dropping(size) { return Object.create(null, { /** * The queue backing this buffer. * * @type {module:chanko/queue~Queue} * @private * @instance */ queue: { value: q() }, /** * The number of items that this queue can hold before it's considered full. * * @type {number} * @private * @instance */ size: { value: size }, /** * A marker property used to show that this is a dropping buffer. * * @type {Symbol} * @private * @instance */ [BUFFER]: { value: DROPPING } }); } /** * A buffer implementation that drops the oldest item when an item is added to a * full buffer. * * This is very similar to * {@link module:chanko/channels.DroppingBuffer|DroppingBuffer}; the only * difference is in what happens when an item is added. In this buffer, the new * item is indeed added to the buffer, but in order to keep the count of the * buffer at or below its size, the oldest item in the buffer is silently * dropped. * * @typedef SlidingBuffer * @memberof module:chanko/channels */ /** * Creates a sliding buffer of the specified capacity. * * A sliding buffer drops the first-added (oldest) item already in the buffer if * a new item is added when the buffer is already at capacity. Since it's always * capable of having items added to it, it's never considered full, and * therefore a put to a channel buffered by a sliding buffer never blocks. * * This buffer is passed to `{@link module:chanko/channels.chan|chan}`, etc. to * create a buffered channel. It is not meant to be used directly. * * @memberof module:chanko/channels * @param {number} size The number of items that the new buffer can hold before * oldest items are dropped on add. * @return {module:chanko/channels.SlidingBuffer} A new sliding buffer of the * specified capacity. */ function sliding(size) { return Object.create(null, { /** * The queue backing this buffer. * * @type {module:chanko/queue~Queue} * @private * @instance */ queue: { value: q() }, /** * The number of items that this queue can hold before it's considered full. * * @type {number} * @private * @instance */ size: { value: size }, /** * A marker property used to show that this is a sliding buffer. * * @type {Symbol} * @private * @instance */ [BUFFER]: { value: SLIDING } }); } /** * Returns the queue that backs a buffer. * * @param {module:chanko/channels.Buffer} buffer The buffer whose queue is * returned by this function. * @return {module:chanko/queue~Queue} The queue that backs the supplied buffer. * @private */ function queue(buffer) { return buffer.queue; } /** * Returns the number of items a buffer can hold before it's full. * * @param {module:chanko/buffer~Buffer} buffer The buffer whose size is returned * by this function. * @return {number} The size of the supplied buffer. * @private */ function size(buffer) { return buffer.size; } /** * Returns the number of items a buffer is currently holding. * * @param {module:chanko/channels.Buffer} buffer The buffer whose current count * is returned by this function. * @return {number} The number of items that the supplied buffer is holding. * @private */ function count(buffer) { return qCount(buffer.queue); } /** * Determines whether a buffer is at capacity. * * @param {module:chanko/channels.Buffer} buffer The buffer who's being checked * to see if it's at capacity. * @return {number} Either `true` if the supplied buffer is full or `false` if * it isn't. * @private */ function isFull(buffer) { return buffer[BUFFER] === FIXED ? qCount(buffer.queue) &gt;= buffer.size : false; } /** * Adds one or more items to a buffer. * * @param {module:chanko/channels.Buffer} buffer The buffer where the supplied * items will be added. * @param {...*} items The values being added to the supplied buffer. * @private */ function add(buffer, ...items) { switch (buffer[BUFFER]) { case FIXED: for (const item of items) { enqueue(buffer.queue, item); } break; case DROPPING: for (const item of items) { if (count(buffer) &lt; size(buffer)) { enqueue(buffer.queue, item); } } break; case SLIDING: for (const item of items) { if (count(buffer) &gt;= size(buffer)) { dequeue(buffer.queue); } enqueue(buffer.queue, item); } break; default: return; } } /** * Removes the next item from a queue and returns it. * * @param {module:chanko/channels.Buffer} buffer The buffer from which an item * is being removed. * @return {*} The item that was removed from the supplied buffer. * @private */ function remove(buffer) { return dequeue(buffer.queue); } export { isBuffer, fixed, dropping, sliding, queue, size, count, isFull, add, remove }; × Search results Close "},"channels_src_modules_channel_index.js.html":{"id":"channels_src_modules_channel_index.js.html","title":"Source: channels/src/modules/channel/index.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/channel/index.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * An implementation of channels. These channels are essentially queues that * hold instructions waiting for the next available async function to process * them. They can be buffered, which is accomplished using the buffer functions * `{@link module:chanko/channels.fixed|fixed}`, * `{@link module:chanko/channels.dropping|dropping}`, and * `{@link module:chanko/channels.sliding|sliding}`. * * Channels do not interact with JS tasks or the dispatcher in any meaningful * way. They're just here to hold tasks which may themselves then cause new JS * tasks to be created via the dispatcher. * * Channels may have transducers associated with them. The transducers are * expected to follow the same conventions as any of the popular transducer * libraries. Explicit support is required because channels wouldn't play well * with the normal way of making an object support transduction, for two * different reasons. * * * Transducers require the ability to create a new, empty collection of the * same type as the input collection. In this case, that would mean creating a * new channel, meaning that the output channel (from which the transformed * values are received) would be different than the input channel (where * values are sent). * * If we somehow get over that requirement and keep all action on the same * channel, we can't take values from the channel, transform them, and put * them back. This would potentially change the order of values in the channel * since we are dealing with asynchronous processes. * * The explicit support means a transducer is directly associated with a * channel. When a value is sent to the channel, it's first run through the * transducer and the transformed value is the one actually put into the * channel's buffer. This avoids both of the problems noted above. * * @module chanko/channel * @private */ import { CLOSED, channel as chanImpl, handleSend, handleRecv, close as closeImpl, MAX_DIRTY, MAX_QUEUED } from \"./handler\"; import { DEFAULT, select, selectAsync, value, channel } from \"./select\"; import { add, fixed, isBuffer } from \"modules/buffer\"; import { protocols as p } from \"modules/protocol\"; /** * A handler function for exceptions that are thrown by a transducer while * transforming values on a channel. * * @param {object} err The error object that was thrown by the transducer. * @return {*} A value that should be put into the channel's buffer when the * transducer throws the error. If this value is * {@link module:chanko/channels.CLOSED|CLOSED}, then no value at all will be * added to the buffer. * @callback ExceptionHandler * @private */ /** * The default exception handler, used when no exception handler is supplied to * `{@link handleException}`, `{@link wrapTransformer}`, * `{@link module:chanko/channels.chan|chan}`, or * `{@link module:chanko/channels.transChan|transChan}`. This default handler * merely returns `{@link module:chanko/channels.CLOSED|CLOSED}`, which will * result in no new value being written to the channel. * * @type {module:chanko~exceptionHandler} * @memberof module:chanko/channel * @private */ const DEFAULT_HANDLER = () =&gt; CLOSED; /** * Creates a new handler used for `send` and `recv` operations. * * @memberof module:chanko/channel * @param {module:chanko/channel~HandlerCallback} fn The callback to be run when * (and if) the operation completes. * @return {module:chanko/channel~Handler} The new handler. * @private */ function opHandler(fn) { return Object.create(null, { active: { value: true }, commit: { value: () =&gt; fn } }); } /** * Handles an exception that is thrown inside a transducer. The thrown error is * passed to the `handler` function, and the result of that handler function is * added to the channel's buffer. If that value is * {@link module:chanko/channels.CLOSED|CLOSED}, then it is *not* added to the * buffer. * * @param {module:chanko/channels.Buffer} buffer The buffer that backs the * channel whose transducer's exceptions are being handled. * @param {module:chanko/channel~exceptionHandler} handler The exception * handling function that is run when an error occurs in a transducer. * @param {Object} ex The error object thrown by the transducer. * @return {module:chanko/channels.Buffer} The buffer itself. This is done to * make it easier to integrate this function into a transducer's step * function. * @private */ function handleException(buffer, handler, ex) { const value = handler(ex); if (value !== CLOSED) { add(buffer, value); } return buffer; } /** * A transducer that wraps another transducer with error handling code. Any * error that occurs within the transducer, either in the step function or the * result function, will cause the error handler to be run. * * @param {Object} xform The transducer to add an error handler to. * @param {ExceptionHandler} [handler=DEFAULT_HANDLER] The exception handling * function that is run when an error occurs in the transducer. * @return {Object} A new transducer that is the result of wrapping the provided * transducer's step and result functions with the exception handler. * @private */ function handlerTransducer(xform, handler = DEFAULT_HANDLER) { return { [p.step](buffer, input) { try { return xform[p.step](buffer, input); } catch (ex) { return handleException(buffer, handler, ex); } }, [p.result](buffer) { try { return xform[p.result](buffer); } catch (ex) { return handleException(buffer, handler, ex); } } }; } /** * The reducer used at the end of a transducer chain to control how the * transformed values are reduced back onto the channel's buffer. This reducer * does nothing more than add the input items (which are the transformed values * that are being put onto the channel) to the channel buffer. * * This is a necessary part of working with a transducer, as the final reducer * always takes the transformed values and renders them into whatever collection * is desired. This is that final reducer for channels. * * @type {Object} * @private */ const bufferReducer = { [p.init]() { throw Error(\"init not available\"); }, [p.step](buffer, input) { add(buffer, input); return buffer; }, [p.result](buffer) { return buffer; } }; /** * Parses the buffer argument and options, along with a set of default options, * to figure out what was really passed to * `{@link module:chanko/channels.chan|chan}`. * * @param {(null|number|module:chanko/channels.Buffer)} buffer The buffer * argument passed to `{@link module:chanko/channels.chan|chan}`. * @param {object} options The options argument passed to * `{@link module:chanko/channels.chan|chan}`. * @param {object} defaultOptions Default values for options that might not have * been sent to `{@link module:chanko/channels.chan|chan}`. * @return {object} An object containing the processed values of all of the * arguments sent to `{@link module:chanko/channels.chan|chan}`. * @private */ function parseArgs(buffer, options, defaultOptions) { let buf; let opts; if (!buffer) { // same for 0, null, or undefined buf = null; opts = options; } else if (typeof buffer === \"number\") { buf = fixed(buffer); opts = options; } else if (isBuffer(buffer)) { buf = buffer; opts = options; } else { // If no buffer is specified but a transducer is, we assume fixed(1) // instead of no buffer buf = buffer?.transducer ? fixed(1) : null; opts = buffer; } const { transducer, handler, maxDirty, maxQueued, timer } = Object.assign( {}, defaultOptions, opts ); return { buf, transducer, handler, maxDirty, maxQueued, timer }; } /** * Creates and returns a new channel. * * By default this channel will be a simple unbuffered, untransformed channel, * but that can be changed through options. A channel does not have any * externally useful functions. It exists largely to be passed into * `{@link module:chanko/channels.send|send}`, * `{@link module:chanko/channels.recv|recv}`, and * `{@link module:chanko/channels.select|select}` invocations, along with their * non-blocking variations * (`{@link module:chanko/channels.sendAsync|sendAsync}`, * `{@link module:chanko/channels.recvAsync|recvAsync}`, and * `{@link module:chanko/channels.selectAsync|selectAsync}`). * * If a buffer value is provided, it defines what buffer should back the * channel. If this is `null` or `0`, the channel will be unbuffered. If it's a * positive number, the channel will be buffered by a * `{@link module:chanko/channels.FixedBuffer|FixedBuffer} `of that size. If * it's a `{@link module:chanko/channels.Buffer|Buffer}` object, that object * will be used as the channel's buffer. If it's missing altogether, the channel * will be unbuffered unless a `transducer` option is provided (see below), in * which case it will be a * `{@link module:chanko/channels.FixedBuffer|FixedBuffer}` of size 1. * * `chan` supports transducers by allowing a transducer function to be * associated with it. This is passed as the `transducer` option and can only be * used if the channel is buffered (otherwise an error is thrown). This * transducer function must take another transducer as a parameter (allowing * transformers to be chained), and it must return an object conforming to the * transducer protocol. * * Errors in the transformation process can be handled by passing an error * handler. This is a function that expects to receive an error object as a * parameter and can return a value that is then put onto the channel. If this * value is `{@link module:chanko/channels.CLOSED|CLOSED}`, then no value will * be put onto the channel upon handler completion. * * @memberof module:chanko/channels * @param {(number|module:chanko/channels.Buffer)} [buffer] The buffer object * that should back this channel. If this is a positive number, a fixed * buffer of that size will be created to back the channel. If it is `0` or * `null`, the new channel will be unbuffered. If it's not present, the new * channel will be unbuffered unless there is a `transducer` option, in in * which case it will be buffered with a size 1 * `{@link module:chanko/channels.FixedBuffer|FixedBuffer}`. * @param {Object} [options] A set of options for configuring the channel's * queue. * @param {module:chanko/channels.Transducer} [options.transducer] A transducer * to run each value through before putting it onto the channel. This * function should expect one parameter (another transducer that it's * chained to) and return an object that conforms to the transducer * protocol. If a transducer is provided on an unbuffered channel, an error * will be thrown. * @param {module:chanko/channels.ExceptionHandler} [options.handler] An error * handler that is run whenever an error occurs inside a transducer * function. If that happens, this function is called with one parameter, * which is the error object. The value that the handler returns (if it is * not `{@link module:chanko/channels.CLOSED|CLOSED}`) will be put onto the * channel when the handler finishes running. * @param {number} [options.maxDirty=64] The maximum number of dirty operations * that can be in the queue before those operations are subject to being * purged. Dirty operations are those that may not be valid anymore because * they were in the list of operations passed to * `{@link module:chanko/channels.select|select}` or * `{@link module:chanko/channels.selectAsync|selectAsync}` but were not * chosen to run. This provides a chance for a very minor performance tweak * and is best left alone. * @param {number} [options.maxQueued=1024] The maximum number of operations * that can be queued up at the same time. This prevents infinite loops from * accidentally eating up all of the available memory. * @param {number} [options.timer] If this value is present, the channel will be * a timed channel that closes automatically after this number of * milliseconds. * @return {module:chanko/channels.Channel} A new channel. */ function chan(buffer, options) { const defaultOptions = { maxDirty: MAX_DIRTY, maxQueued: MAX_QUEUED }; const { buf, transducer, handler, maxDirty, maxQueued, timer } = parseArgs( buffer, options, defaultOptions ); if (transducer &amp;&amp; !buf) { throw Error(\"Only buffered channels can use transducers\"); } const xf = handlerTransducer( transducer ? transducer(bufferReducer) : bufferReducer, handler ); const isTimed = typeof timer === \"number\"; const ch = chanImpl(buf, xf, isTimed, maxDirty, maxQueued); async function* iterator() { for (;;) { const value = await recv(ch); if (value === CLOSED) { break; } yield value; } } ch[Symbol.asyncIterator] = iterator; if (isTimed) { setTimeout(() =&gt; closeImpl(ch), timer); } return ch; } /** * Creates an unbuffered, timed channel. This channel closes automatically after * the supplied number of milliseconds and is the equivalent of calling `chan(0, * { timer: delay })`. * * @memberof module:chanko/channels * @param {number} delay The number of milliseconds after the channel is created * that it will be closed automatically. * @return {module:chanko/channels.Channel} A new timed channel. */ function timedChan(delay = 0) { return chan({ timer: delay }); } /** * Creates a buffered channel with a transducer and optional error handler. The * buffer for this channel is a * `{@link module:chanko/channels.FixedBuffer|FixedBuffer}` of size 1. This is * the equivalent of `chan(1, { transducer, handler })`. * * @memberof module:chanko/channels * @param {module:chanko/channels.Transducer} transducer The transducer used to * transform values on the new channel. * @param {module:chanko/channels.ExceptionHandler} [handler] An exception * handler called with the error object as its only argument when an error * happens inside a transducer. If this is not provided, a default handler * is used that simply does nothing, including sending no output from the * value that errored. * @return {module:chanko/channels.Channel} A new channel with a transducer. */ function transChan(transducer, handler) { return chan({ transducer, handler }); } /** * Determines whether a channel is closed. * * A closed channel will cause any `send` operation to return `false` and any * `recv` operation to return any buffered items that remain, followed by * `{@link module:chanko/channels.CLOSED|CLOSED}`. * * @memberof module:chanko/channels * @param {module:chanko/channels.Channel} channel The channel to check. * @return {boolean} Either `true` if the channel is closed or `false` if it * isn't. */ function isClosed(channel) { return channel.closed; } /** * Determines whether a channel is buffered. * * A channel is buffered if a buffer or a number was passed as the first * argument of `{@link module:chanko/channels.chan|chan}` or if a transducer is a * part of the channel. * * @memberof module:chanko/channels * @param {module:chanko/channels.Channel} channel The channel to check. * @return {boolean} Either `true` if the channel is buffered or `false` if it * isn't. */ function isBuffered(channel) { return channel.isBuffered; } /** * Determines whether a channel is timed. * * A channel is timed if it was created either with the `timer` option of * `{@link module:chanko/channels.chan|chan}` or with the * `{@link module:chanko/channels.timedChan|timedChan}` function. It will * automatically close after a certain period of time. * * @memberof module:chanko/channels * @param {module:chanko/channels.Channel} channel The channel to check. * @return {boolean} Either `true` if the channel is timed or `false` if it * isn't. */ function isTimed(channel) { return channel.isTimed; } /** * Sends a value to this channel without blocking. * * This means that a call to `sendAsync` does not go into an `await` expression, * and it is not necessary to use it inside a async function. Rather than * blocking until the sent value is taken by another async function, this one * returns immediately and then invokes the callback (if provided) when the sent * value is taken. It can be seen as a non-blocking version of * `{@link module:chanko/channels.send|send}`. * * While the primary use of this function is to send values onto channels in * contexts where being inside an async function is impossible (for example, in * a DOM element's event handler), it can still be used inside async functions * at times when it's important to make sure that the function doesn't block * from the send. * * The callback is a function of one parameter. The parameter that's supplied to * the callback is the same as what is supplied to `await send`: `true` if the * value was taken, or `false` if the channel was closed. If the callback isn't * present, nothing will happen after the value is taken. * * @memberof module:chanko/channels * @param {*} [value] The value being put onto the channel. * @param {module:chanko/channels.OpCallback} [callback] A function that gets * invoked either when the value is taken by another process or when the * channel is closed. This function can take one parameter, which is `true` * in the former case and `false` in the latter. */ function sendAsync(channel, value, callback = () =&gt; {}) { const result = handleSend(channel, value, opHandler(callback)); if (result &amp;&amp; callback) { callback(result.value); } } /** * Receives a value from this channel without blocking. * * This means that a call to `receiveAsync` does not go into an `await` * expression, and it is not necessary to use it inside a async function. Rather * than blocking until a value becomes available on the channel to be received, * this one returns immediately and then invokes the callback (if provided) when * a value becomes available. It can be regarded as a non-blocking version of * {@link module:chanko/channels.recv|recv}`. * * While the primary use of this function is to receive values from channels in * contexts where being inside an async function is impossible, it can still be * used inside async functions at times when it's important that the receive * doesn't block the function. * * The callback is a function of one parameter, and the value supplied for that * parameter is the value received from the channel (either a value that was * sent or `{@link module:chanko/channels.CLOSED|CLOSED}`). If the callback * isn't present, nothing will happen after the value is taken. * * @memberof module:chanko/channels * @param {module:chanko/channels.OpCallback} [callback] A function that gets * invoked when a value is made available to be received (this value may be * `{@link module:chanko/channels.CLOSED|CLOSED}` if the channel closes with * no available value). The function can take one parameter, which is the * value that is received from the channel. */ function recvAsync(channel, callback = () =&gt; {}) { const result = handleRecv(channel, opHandler(callback)); if (result &amp;&amp; callback) { callback(result.value); } } /** * Sends a value to a channel, blocking the async function until that value is * received from the channel by a different function (or until the channel * closes). * * A value is always sent to the channel, but if that value isn't specified by * the second parameter, it is `undefined`. Any value may be sent to a channel, * with the sole exception of the special value * `{@link module:chanko/channels.CLOSED|CLOSED}`. * * This function *must* be called from within an async function and as part of * an `await` expression. * * When `send` is completed and its function unblocks, its `await` expression * evaluates to a status boolean that indicates what caused the function to * unblock. That value is `true` if the sent value was successfully taken by * another process, or `false` if the unblocking happened because the target * channel closed. * * @memberof module:chanko/channels * @param {*} [value] The value being put onto the channel. * @return {Promise&lt;boolean&gt;} A promise that will resolve to `true` or `false` * depending on whether the put value is actually taken. */ function send(channel, value) { return new Promise(resolve =&gt; { sendAsync(channel, value, resolve); }); } /** * Receives a value from this channel, blocking the async function until a * value becomes available to be received (or until the channel closes with * no more values on it to be received). * * This function *must* be called from within an async function and as part * of an `await` expression. * * When `receive` is completed and its function unblocks, its `await` * expression evaluates to the actual value that was received. If the target * channel closed, then all of the values already placed onto it are * resolved by `receive` as normal, and once no more values are available, * the special value `{@link module:chanko/channels.CLOSED|CLOSED}` is returned. * * @memberof module:chanko/channels * @return {Promise} A promise that will resolve to the value received from * the channel once that receive is completed. If the channel closes * without a value being made available, this will resolve to * `{@link module:chanko/channels.CLOSED|CLOSED}`. */ function recv(channel) { return new Promise(resolve =&gt; { recvAsync(channel, resolve); }); } /** * Receives a value from a channel, blocking the async function until a value * becomes available to be received (or until the channel closes with no more * values on it to be received). If the received value is an error object, that * error is thrown at that point. * * This function *must* be called from within an async function and as part of * an `await` expression. * * It functions in every way like `{@link module:chanko/channels.recv|recv}` * *except* in the case that the value on the channel is an object that has * `Error.prototype` in its prototype chain (any built-in error, any * properly-constructed custom error). If that happens, the error is thrown, * which will cause the returned promise to be rejected with the error. It can * then be handled up the promise chain like any other rejected promise. * * `takeOrThrow` is roughly equivalent to: * * ``` * const value = await recv(ch); * if (Error.prototype.isPrototypeOf(value)) { * throw value; * } * ``` * * @memberof module:chanko/channels * @return {Promise} A promise that will resolve to the value taken from the * channel once that take is completed. If the channel closes without a * value being made available, this will resolve to * `{@link module:chanko~Chanko.CLOSED|CLOSED}`. If the taken value is an * error, the promise will instead be rejected with the error object as the * reason. */ function recvOrThrow(channel) { return new Promise((resolve, reject) =&gt; { recvAsync(channel, result =&gt; { if (Object.prototype.isPrototypeOf.call(Error.prototype, result)) { reject(result); } else { resolve(result); } }); }); } /** * Closes the channel, if it isn't already closed. This immediately returns any * buffered values to pending receives. If there are no buffered values (or if * they've already been taken by other receives), then all of the rest of the * receives are completed with the value of * `{@link module:chanko/channels.CLOSED|CLOSED}`. Any pending sends are * completed with the value of `false`. * * Note that the buffer is not emptied if there are still values remaining after * all of the pending receives have been handled. The channel will still provide * those values to any future receives, though no new values may be added to the * channel. Once the buffer is depleted, any future receives will return * `{@link module:chanko/channels.CLOSED|CLOSED}`. * * @memberof module:chanko/channels * @param {module:chanko/channels.Channel} channel The channel to be closed. */ function close(channel) { closeImpl(channel); } export { CLOSED, DEFAULT, chan, timedChan, transChan, isClosed, isBuffered, isTimed, sendAsync, recvAsync, selectAsync, send, recv, recvOrThrow, select, close, value, channel }; /** * Used by channels to track execution of operations (`send`, `recv`, and * `select`). They provide two pieces of information: the function to call when * a `send` or `recv` unblocks (because a value given to send has been received, * or a `recv` has accepted a value that has been sent) and whether or not the * handler is still active. * * The function is a callback that actually defines the difference between * `{@link module:chanko/channels.send|send}` / * `{@link module:chanko/channels.recv|recv}` / * `{@link module:chanko/channels.select|select}` and * `{@link module:chanko/channels.sendAsync|sendAsync}` / * `{@link module:chanko/channels.recvAsync|recvAsync}` / * `{@link module:chanko/channels.selectAsync|selectAsync}`: while the unblocked * calls use the callback passed to the function, `send`, `recv`, and `select` * simply continue the process where it left off. (This is why `send`, `recv`, * and `select` only work inside `async` functions with `await` if the return * value is needed, because otherwise there's no process to continue.) * * This function is provided as the return value of the `commit` method. Calling * `commit` has no extra effect with `send` and `recv` operations, but for * `select`, it also marks the handler as no longer being active. This means * that only one of the operations passed to select can be completed, because * after the first one, the handler is no longer active and will not be allowed * to process a second operation. * * If a `send` or `recv` (or equivalent `select` operation) cannot be * immediately completed because there isn't a corresponding pending `recv` or * `send`, the handler is queued to be run when a new `recv` or `send` becomes * available. * * @typedef Handler * @property {boolean} active Whether or not the operation is still active. An * inactive operation is not serviced and will be cleared from the queue on * the next dirty operation purge. * @property {function} commit Marks the handler as inactive (so it doesn't run * twice) and returns the callback to be run when the operation completes. * @private */ /** * A callback function run when a `send` or `recv` operation completes. * * @callback HandlerCallback * @param {*} value The value provided by the channel. In a `recv`, this is the * value received from the channel. In a `send`, this is `true` for a * successful send and `false` if the channel is closed before the send can * complete. * @private */ × Search results Close "},"channels_src_modules_channel_handler.js.html":{"id":"channels_src_modules_channel_handler.js.html","title":"Source: channels/src/modules/channel/handler.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/channel/handler.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ import { protocols as p } from \"modules/protocol\"; import { queue, dequeue, EMPTY, filter, count as qCount, enqueue } from \"modules/queue\"; import { isFull, count, remove } from \"modules/buffer\"; import { dispatch } from \"modules/dispatcher\"; /** * The maximum number of dirty operations that can be queued on a channel before * a cleanup is triggered. * * @type {number} * @private */ const MAX_DIRTY = 64; /** * The maximum number of opertions that can be queued on a channel before new * operations are rejected. * * @type {number} * @private */ const MAX_QUEUED = 1024; /** * *he value returned from a receive on a channel when that channel is closed * and has no more values available. * * This is a special value that is returned under a certain circumstance, namely * when a receive is performed on a closed channel. Because of that, it cannot * be returned from a receive on an open channel. For that reason, `CLOSED` is * the only value that cannot be sent onto a channel &amp;mdash; it would be * impossible to distinguish between a legitimate value of `CLOSED` and an * actual closed channel. * * @type {Symbol} * @memberof module:chanko/channels */ const CLOSED = Symbol(\"CLOSED\"); /** * A unique value used to indicate that an object is a box. * * @type {Symbol} * @private */ const BOX = Symbol(\"BOX\"); /** * Determines whether an object is a box. * * @param {*} obj A value to check for boxiness. * @return Either `true` if the value is a box or `false` if it isn't. * @private */ function isBox(obj) { return !!obj?.[BOX]; } /** * Determines whether an object is reduced. This is done using the transducer * protocol; an object with the protocol-specified `reduced` property is assumed * to be reduced. If a result of a transformation is reduced, it means that the * transformation is complete and the channel should be closed. * * @param {*} value The value being checked for reduction. * @return {boolean} Either `true` if the value has been reduced, or `false` if it has * not been. * @private */ function isReduced(value) { return !!value?.[p.reduced]; } /** * A wrapper around a value. This is primarily used as a marker; a put or take * returning a Box indicates that the put or take has returned an immediate * value, while returning `null` indicates that the operation has been queued. * * @typedef Box * @memberof module:chanko/channel * @property {*} value The value being wrapped by the box. * @private */ /** * A wrapper object for a value. This is used almost entirely as a marker * interface, though the fact that it becomes a parameter that's passed by * reference rather than value is also important in a couple places. If a * channel operation (put or take) returns a Box, it means that an actual value * was returned. A non-Box (which always happens to be `null`) means that the * operation must block. * * @memberof module:chanko/channel * @param {*} value The value to box. * @return {module:chanko/channel~Box} The boxed value. * @private */ function box(value) { return Object.create(null, { value: { value, writable: true }, [BOX]: { value: true } }); } /** * A wrapper around a value. This is much like * {@link module:chanko/channel~Box|Box} except that it also carries a handler * to be used when a sent value is received. It is specifically for queueing * sends. * * @typedef SendBox * @memberof module:chanko/channel * @property {*} value The value being wrapped by this box. * @property {module:chanko/channel~Handler} handler The handler used to process * a send request for the value. * @private */ /** * A box used to wrap a value being sent onto a channel. This is different from * a regular box in that the send handler is also included. * * @memberof module:chanko/channel * @param {Object} handler The handler used to process a send request for the * value. * @param {*} value The value to box. * @return {module:chanko/channel~SendBox} The boxed value. * @private */ function sendBox(value, handler) { return Object.create(null, { value: { value, writable: true }, handler: { value: handler }, [BOX]: { value: true } }); } /** * A channel, used by processes to communicate with one another. * * For each operation, the channel first tests to see if there's a corresponding * operation already queued (i.e., if we're doing a `send` that there's a queued * `recv` and vice versa). If there is, that corresponding operation is * unblocked and both operations complete. If not, the operation is queued to * wait for a corresponding operation. The process or that created the operation * then blocks. * * The channel can be backed by a buffer, though it is not by default. If a * buffer is in place, and that buffer is not full, then the process that * created an operation that has to be queued is *not* blocked. * * This channel object supports transformations, assuming that they follow the * protocol created by a few transducer library authors to allow them to * interoperate. The support must be explicitly created because the normal * method of making an object support transformations won't work here. This * method is to create a new object and add the transformed values to it - but * for a channel, we need to replace the values on the channel with their * transformed values, in the same order even in a multi-process environment. * Thus transformations happen in place. * * Transformations are applied before the value is queued, so even if there is a * corresponding operation ready to go, the transformation still happens. Also, * transformations require that the channel be buffered (this buffer is what is * sent to the transformer's reduction step function); trying to create a * channel with a transformer but without a buffer will result in an error being * thrown. * * This is the object that is returned from a call to * `{@link module:chanko/channels.chan|chan}`. However, this object is intended to * be used as a value to pass to channel operation functions; it doesn't have * any properties of interest to an end user. * * @memberof module:chanko/channels * @typedef Channel */ /** * Creates a channel. This is a low-level function; * `{@link module:chanko~Chanko.chan|chan}` performs some necessary * manipulations on arguments before using this function to perform the actual * creation. * * @memberof module:chanko/channel * @param {null | module:chanko/buffer~Buffer} buffer An optional buffer that, * if present, is used to create a buffered channel. If this is `null`, an * unbuffered channel is created. * @param {module:chanko~transducer} xform The transducer used to transform * values sent to the channel. If no transformations are necessary, a * passthrough transducer should be provided. * @param {boolean} isTimed Indicates whether the channel is a timed channel. * The timining mechanism is handled outside the channel, but this property * is provided to be able to query whether that's the case. * @param {number} maxDirty=64 The maximum number of dirty operations to allow * before they're purged. * @param {number} maxQueued=1024 The maximum number of operations that can be * queued before new ones are rejected. * @return {module:chanko/channel.Channel} A new channel. * @private */ function channel( buffer, xform, isTimed = false, maxDirty = MAX_DIRTY, maxQueued = MAX_QUEUED ) { return Object.create(null, { buffer: { value: buffer }, xform: { value: xform }, maxDirty: { value: maxDirty }, maxQueued: { value: maxQueued }, recvs: { value: queue() }, sends: { value: queue() }, dirtyRecvs: { value: 0, writable: true }, dirtySends: { value: 0, writable: true }, closed: { value: false, writable: true }, isBuffered: { value: !!buffer }, isTimed: { value: isTimed } }); } /** * Sends a value to a channel. The specified handler is used to control whether * the send is active and what to do after the send completes. A send can become * inactive if it was part of an `select` call and some other operation * specified in that call has already completed. * * This value is given to a receive handler immediately if there's one waiting. * Otherwise the value and handler are queued together to wait for a receive. * * This is a low-level operation that's provided as a part of the channel * implementation so that other operations functions can properly apply * handlers. It is not meant for general use. Use those other operations * functions instead. * * * @memberof module:chanko/channel * @param {module:chanko/channels.Channel} channel The channel that the value is * being sent to. * @param {*} value The value to be put onto the channel. * @param {boolean} handler.active Determines whether the send is still active * and should still be serviced. * @param {function} handler.commit Deactivates the send (so it can't be * serviced a second time) and returns the callback to be fired when the * send completes. * @return {module:chanko/channel~Box|null} One of three values. A boxed `true` * is returned if the send was immediately consumed by a pending receive. A * boxed `false` is returned if the send was performed on a channel that was * already closed by the time the send took place. `null` is returned if the * send was queued pending a corresponding receive. * @private */ function handleSend(channel, value, handler) { if (value === CLOSED) { throw Error(\"Cannot send CLOSED to a channel\"); } if (channel.closed) { handler.commit(); return box(false); } let receiver, callback; // Push the incoming value through the buffer, even if there's already a // receiver waiting for the value. This is to make sure that the transducer // step function has a chance to act on the value first, which could change // the value or make it altogether unavailable. // // If the channel is unbuffered this process is skipped (there can't be a // transducer on an unbuffered channel anyway). If the buffer is full, the // transducer's work is deferred until later when the buffer is not full. if (channel.buffer &amp;&amp; !isFull(channel.buffer)) { handler.commit(); const done = isReduced(channel.xform[p.step](channel.buffer, value)); for (;;) { if (count(channel.buffer) === 0) { break; } receiver = dequeue(channel.recvs); if (receiver === EMPTY) { break; } if (receiver.active) { callback = receiver.commit(); const val = remove(channel.buffer); if (callback) { dispatch(() =&gt; callback(val)); } } } if (done) { close(channel); } return box(true); } // This loop happens if the channel is unbuffered and there is at least one // pending receive. (Buffered channels break out of this loop immediately, // because in order for a buffered channel to reach this point, its buffer // must have been full. If the buffer is full, that means there are no pending // receives and the first one read will be EMPTY.) It processes the next // pending receive immediately. for (;;) { receiver = dequeue(channel.recvs); if (receiver === EMPTY) { break; } if (receiver.active) { handler.commit(); callback = receiver.commit(); if (callback) { dispatch(() =&gt; callback(value)); } return box(true); } } // If there are no pending receives on an unbuffered channel, or on a buffered // channel with a full buffer, we queue the send to tlet it wait for a receive // to become available. Sends whose handlers have gone inactive (which happens // if they were processed as part of a `select` call) are periodically purged. if (channel.dirtySends &gt; channel.maxDirty) { filter(channel.sends, sender =&gt; sender.handler.active); channel.dirtySends = 0; } else { channel.dirtySends++; } if (qCount(channel.sends) &gt;= channel.maxQueued) { throw Error( `No more than ${channel.maxQueued} pending sends are allowed on a single channel` ); } enqueue(channel.sends, sendBox(value, handler)); return null; } /** * Receives a value from a channel. The specified handler is used to control * whether the receive is active and what to do after the receive completes. A * receive can become inactive if it was part of an `select` call and some other * operation specified in that call has already completed. * * This value is given to a send handler immediately if there's one waiting. * Otherwise the value and handler are queued together to wait for a send. * * This is a low-level operation that's provided as a part of the channel * implementation so that other operations functions can properly apply * handlers. It is not meant for general use. Use those other operations * functions instead. * * @memberof module:chanko/channel * @param {module:chanko/channels.Channel} channel The channel that the value is * being received from. * @param {boolean} handler.active Determines whether the receive is still * active and should still be serviced. * @param {function} handler.commit Deactivates the receive (so it can't be * serviced a second time) and returns the callback to be fired when the * receive completes. * @return {module:chanko/channel~Box|null} Either the boxed value received from * the channel, or `null` if the receive must be queued to await a * corresponding send. * @private */ function handleRecv(channel, handler) { let sender, sendHandler, callback; // Runs if the channel is buffered and the buffered is not empty (an empty // buffer means there are no pending sends). We immediately process any sends // that were queued when there were no pending receives, up until the buffer // is filled with sent values. if (channel.buffer &amp;&amp; count(channel.buffer) &gt; 0) { handler.commit(); const value = remove(channel.buffer); for (;;) { if (isFull(channel.buffer)) { break; } sender = dequeue(channel.sends); if (sender === EMPTY) { break; } sendHandler = sender.handler; if (sendHandler.active) { callback = sendHandler.commit(); if (callback) { dispatch(() =&gt; callback(true)); } if (isReduced(channel.xform[p.step](channel.buffer, sender.value))) { close(channel); } } } return box(value); } // This loop runs on an unbuffered channel if there are any pending sends. // (Buffered channels break out of this loop immediately because in order to // have come this far without returning, the channel's buffer must have been // empty. An empty buffer means there are no pending sends, so the first // pending send read from it will be EMPTY.) It processes the next pending // send immediately. for (;;) { sender = dequeue(channel.sends); if (sender === EMPTY) { break; } sendHandler = sender.handler; if (sendHandler.active) { callback = sendHandler.commit(); if (callback) { dispatch(() =&gt; callback(true)); } return box(sender.value); } } // If we've exhausted all of our pending sends and the channel is marked // closed, we can finally reutrn the fact that the channel is closed. This // ensures that any sends that were already pending on the channel are // processed before closure, even if the channel was closed before that could // happen. if (channel.closed) { handler.commit(); return box(CLOSED); } // If an unbuffered channel or a buffered channel with an empty buffer has no // pending sends, and if the channel is still open, the receive is queued to // be processed when a send is available. Receives whose handlers have gone // inactive as the result of `select` processing are periodically purged. if (channel.dirtyRecvs &gt; channel.maxDirty) { filter(channel.recvs, receiver =&gt; receiver.active); channel.dirtyRecvs = 0; } else { channel.dirtyRecvs++; } if (qCount(channel.recvs) &gt;= channel.maxQueued) { throw Error( `No more than ${channel.maxQueued} pending receives are allowed on a single channel` ); } enqueue(channel.recvs, handler); return null; } /** * Closes the channel if it isn't already closed. This immediately returns any * buffered values to pending receives. If there are no buffered values (or if * they've already been taken by other receives), then all of the rest of the * receives are completed with the value of {@link module:chanko~CLOSED|CLOSED}. * Any pending sends are completed with the value of `false`. * * Note that the buffer is not emptied if there are still values remaining after * all of the pending receives have been handled. The channel will still provide * those values to any future receives, though no new values may be added to the * channel. Once the buffer is depleted, any future receives will return * {@link module:chanko~CLOSED|CLOSED}. * * @memberof module:chanko/channels * @param {module:chanko/channels.Channel} channel The channel to be closed. * @private */ function close(channel) { if (channel.closed) { return; } channel.closed = true; let receiver, sender, callback; // If there is a buffer and it has at least one value in it, send those values // to any pending receives that might still be queued. if (channel.buffer) { channel.xform[p.result](channel.buffer); for (;;) { if (count(channel.buffer) === 0) { break; } receiver = dequeue(channel.recvs); if (receiver === EMPTY) { break; } if (receiver.active) { callback = receiver.commit(); const value = remove(channel.buffer); if (callback) { dispatch(() =&gt; callback(value)); } } } } // Once the buffer is empty (or if there isn't a buffer at all), send CLOSED // to all remaining queued receives. for (;;) { receiver = dequeue(channel.recvs); if (receiver === EMPTY) { break; } if (receiver.active) { callback = receiver.commit(); if (callback) { dispatch(() =&gt; callback(CLOSED)); } } } // Send `false` to any remaining queued sends. for (;;) { sender = dequeue(channel.sends); if (sender === EMPTY) { break; } if (sender.handler.active) { callback = sender.handler.commit(); if (callback) { dispatch(() =&gt; callback(false)); } } } } export { CLOSED, MAX_DIRTY, MAX_QUEUED, channel, handleSend, handleRecv, close, box, isBox }; × Search results Close "},"channels_src_modules_channel_select.js.html":{"id":"channels_src_modules_channel_select.js.html","title":"Source: channels/src/modules/channel/select.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/channel/select.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ import { box, handleSend, handleRecv, isBox } from \"./handler\"; /** * The name of the channel returned from `await * {@link module:chanko/channels.select|select}` or sent to the callback in * `{@link module:chanko/channels.selectAsync|selectAsync}` when the default is * returned as its value. * * This only happens when an `{@link module:chanko/channels.select|select} / * {@link module:chanko/channels.selectAsync|selectAsync}` call is performed, * all operations are initially blocking, and a `default` option is sent. The * immediate response in that situation is `{ value: options.default, channel: * DEFAULT }`. * * @type {Symbol} * @memberof module:chanko/channels */ const DEFAULT = Symbol(\"DEFAULT\"); /** * Creates a new handler used for `select` operations. * * @memberof module:chanko/channel * @param {module:chanko/channel~Box} active A boxed value indicating whether * the handler is valid. This is a boxed value because the select-handling * code needs to manipulate it directly. * @param {module:chanko/channel~HandlerCallback} fn The callback to be run when * (and if) the operation completes. * @return {module:chanko/channel~Handler} The new handler. * @private */ function selectHandler(active, fn) { return Object.create(null, { active: { get() { return active.value; } }, commit: { value: () =&gt; { active.value = false; return fn; } } }); } /** * Creates a randomly shuffled array containing one of each integer value from * `0` to an upper limit. It is used to randomly select a channel to be active * when multiples unblock in a `select` operation. * * @memberof module:chanko/channel * @param {number} upper The upper limit of the array values, exclusive. * @return {number[]} An array of integers from `0` to `upper - 1`, shuffled * into a random order. * @private */ function randomArray(upper) { const array = []; for (let k = 0; k &lt; upper; k++) { array.push(k); } for (let j = upper - 1; j &gt; 0; j--) { const i = Math.floor(Math.random() * (j + 1)); const temp = array[j]; array[j] = array[i]; array[i] = temp; } return array; } /** * A result that comes from `select` operations. * * @typedef SelectResult * @property {*} value If the `select` operation resulted in a receive, this is * the value received from the channel. If it resulted in a send, this is * `true` for a successful send and `false` if the channel closed first. * @property {module:chanko/channels.Channel} channel The channel upon which the * selected operation happened. * @memberof module:chanko/channels */ /** * Creates a select result from its component properties. * * @memberof module:chanko/channel * @param {*} value If the `select` operation resulted in a receive, this is * the value received from the channel. If it resulted in a send, this is * `true` for a successful send and `false` if the channel closed first. * @param {module:chanko/channels.Channel} channel The channel upon which the * selected operation happened. * @return {module:chanko/channels.SelectResult} The properties wrapped into an * object for output. * @private */ function selectResult(value, channel) { return Object.assign(Object.create(null), { value, channel }); } /** * Completes the first operation among the provided operations that comes * available, without blocking. * * This means that a call to `selectAsync` does not go into an `await` * expression, and it is not necessary to use it inside a process. Rather than * blocking until an operation completes, this one returns immediately and then * invokes the callback (if provided) as soon as one of the supplied operations * completes. It can be regarded as a non-blocking version of * `{@link module:chanko/channels.select|select}`. * * This function uses an operations list that's identical to the one used by * `{@link module:chanko/channels.select|select}`. It's an array of values; if a * value is a channel, then that operation is a take on that channel, while if * it's a two-element array of channel and value, then that operation is a put * of that value onto that channel. All options that are available to * `{@link module:chanko/channels.select|select}` are also available here. * * The callback is a function of one parameter, which in this case is an object * with `value` and `channel` properties. * * @memberof module:chanko/channels * @param {Object[]} operations A collection of elements that correspond to recv * and send operations. A recv operation is signified by an element that is * a channel (which is the channel to be received from). A send operation is * specified by an element that is itself a two-element array, which has a * channel followed by a value (which is the channel and value to be sent). * @param {module:chanko/channels.SelectCallback} callback A function that gets * invoked when one of the operations completes. * @param {Object} [options={}] An optional object which can change the behavior * of `selectAsync` through two properties. * @param {boolean} [options.priority=false] If `true`, then the priority of * operations to complete when more than one is immediately available is a * priority according to position within the operations array (earlier * positions have the higher priority). If `false` or not present, the * priorty of operation completion is random. * @param {*} [options.default] If set and all of the operations initially * block, the `selectAsync` calls its callback immediately with the value of * this option (the channel will be * `{@link module:chanko/channels.DEFAULT|DEFAULT})`. If not set, the * `selectAsync` call will not call its callback until one of the operations * completes and that value and channel will be the ones returned. */ function selectAsync(ops, callback = () =&gt; {}, options = {}) { const count = ops.length; if (count === 0) { throw Error(\"select called with no operations\"); } const priority = !!options.priority; const indices = priority ? [] : randomArray(count); const active = box(true); function createSelectHandler(channel) { return selectHandler(active, value =&gt; { callback(selectResult(value, channel)); }); } let result; for (let i = 0; i &lt; count; i++) { // Choose an operation. If `priority` is true then it's the next index, // otherwise it's random const op = ops[priority ? i : indices[i]]; let channel, value; // Apply every operation to its channel, one at a time if (Array.isArray(op)) { [channel, value] = op; result = handleSend(channel, value, createSelectHandler(channel)); } else { channel = op; result = handleRecv(channel, createSelectHandler(channel)); } // We check for box here because a box from a channel indicates that the // value is immediately available (that there is no need to block to get the // value). If this happens, we execute the callback immediately with that // value and channel and stop queueing other operations. if (isBox(result)) { callback(selectResult(result.value, channel)); break; } } // If none of the operaetions immediately returned values (they are all // blocked), and we have set a default channel option, then return the value // if the default channel rather than waiting for the queued operations to // complete. if ( !isBox(result) &amp;&amp; Object.prototype.hasOwnProperty.call(options, \"default\") ) { if (active.value) { active.value = false; callback(selectResult(options.default, DEFAULT)); } } } /** * Completes the first operation among the provided operations that comes * available, blocking the process until then. * * `operations` is an array whose elements must be channels or two-element * sub-arrays of channels and values, in any combination. An operation that is a * channel is a take operation on that channel. An operation that is a * two-element array is a put operation on that channel using that value. * Exactly one of these operations will complete, and it will be the first * operation that unblocks. * * This function *must* be called from within an `async` function and as part of * an `await` expression if the return value is needed. * * When `select` is completed and its process unblocks, its `await` expression * evaluates to an object of two properties. The `value` property becomes * exactly what would have been returned by the equivalent `await put` or `await * take` operation: a boolean in the case of a put, or the taken value in the * case of a take. The `channel` property is set to the channel where the * operation actually took place. This will be equivalent to the channel in the * `operations` array which completed first, allowing the process to unblock. * * If there is more than one operation already available to complete when the * call to `select` is made, the operation with the highest priority will be the * one to complete. Regularly, priority is non-deterministic (i.e., it's set * randomly). However, if the options object has a `priority` value set to * `true`, priority will be assigned in the order of the operations in the * supplied array. * * If all of the operations must block (i.e., there are no pending puts for take * operations, or takes for put operations), a default value may be returned. * This is only done if there is a `default` property in the options object, and * the value of that property becomes the value returned by `await select`. The * channel is set to the special value * `{@link module:chanko/channels.DEFAULT|DEFAULT}`. * * @memberof module:chanko/channels * @param {object[]} operations A collection of elements that correspond to recv * and send operations. A recv operation is signified by an element that is * a channel (which is the channel to be taken from). A send operation is * specified by an element that is itself a two-element array, which has a * channel followed by a value (which is the channel and value to be sent). * @param {object} [options={}] An optional object which can change the behavior * of `select` through two properties. * @param {boolean} [options.priority=false] If `true`, then the priority of * operations to complete when more than one is immediately available is a * priority according to position within the operations array (earlier * positions have the higher priority). If `false` or not present, the * priorty of operation completion is random. * @param {*} [options.default] If set and all of the operations initially * block, the `select` call completes immediately with the value of this * option (the channel will be * `{@link module:chanko/channels.DEFAULT|DEFAULT})`. If not set, the * `select` call will block until one of the operations completes and that * value and channel will be the ones returned. * @return {Promise&lt;module:chanko/channels.SelectResult&gt;} A promise that will * resolve to an object of two properties: `value` will contain the value * that would have been returned by the corresponding * `{@link module:chanko/channels.send|send}` or * `{@link module:chanko/channels.recv|recv}` operation; and `channel` will * be a reference to the channel that completed the operation to allow * `select` to unblock. */ function select(ops, options = {}) { return new Promise(resolve =&gt; { selectAsync(ops, resolve, options); }); } /** * A convenience function to read the value out of a select result. This * function is not necessary - after all, it's absolutely as correct to simply * use `result.value` instead of `value(result)`, but it's provided for * consistency with the rest of the function-centric API. * * @memberof module:chanko/channels * @param {module:chanko/channels.SelectResult} result The result coming from a * select operation. * @return {*} The value provided by the select operation. */ function value(result) { return result.value; } /** * A convenience function to read the channel out of a select result. This * function is not necessary - after all, it's absolutely as correct to simply * use `result.channel` instead of `channel(result)`, but it's provided for * consistency with the rest of the function-centric API. * * @memberof module:chanko/channels * @param {module:chanko/channels.SelectResult} result The result coming from a * select operation. * @return {module:chanko/channels.Channel} The channel upon which the select * operation completed. */ function channel(result) { return result.channel; } export { DEFAULT, select, selectAsync, value, channel }; × Search results Close "},"channels_src_modules_dispatcher.js.html":{"id":"channels_src_modules_dispatcher.js.html","title":"Source: channels/src/modules/dispatcher.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/dispatcher.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * This is the place where the new JS tasks are actually created. A queue is * maintained for them, and as each batch of tasks are completed, the next ones * run. As each process runs, it adds tasks to be run to the queue, which are * each run in their own JS task. * * The function that spawns the new JS task depends on environment. The * `setImmediate` function is preferred as it's the fastest, not waiting for * event queues to empty before spawning the new process. However, it is not JS * standard and currently only works in IE and Node. If `setImmediate` isn't * available, an attempt is made to use `MessageChannel`'s `onMessage` is tried * next. If that is also not available, then `setTimeout` with `0` delay is * used, which is available everywhere but which is the least performant of all * of the solutions. * * There are other possibilities for creating processes, but they were rejected * as obsolete (`process.nextTick` and `onreadystatechange`) or unnecessary * (`window.postMessage`, which works like `MessageChannel` but doesn't work in * Web Workers). * * It is notable and important that we act as good citizens here. This * dispatcher is capable of taking control of the JavaScript engine until * thousands, millions, or more tasks are handled. But that could cause the * system event loop to have to wait an unacceptable amount of time. So we limit * ourselves to a batch of tasks at a time, and if there are still more to be * run, we let the event loop run before that next batch is processed. * * The dispatcher is **global**. There is a single instance that runs for all * channels and processes. This is the only element of the system that works * like this. * * @module chanko/dispatcher * @see module:chanko/channel.config * @private */ import { queue as q, EMPTY, count as qCount, dequeue, enqueue } from \"modules/queue\"; const queue = q(); /** * The dispatch method option indicating that `setImmediate` should be used to * dispatch tasks. * * This is the default option. For environments that don't support * `setImmediate`, this falls back to * `{@link module:chanko/channels.MESSAGE_CHANNEL|MESSAGE_CHANNEL}`. * * @memberof module:chanko/channels * @type {Symbol} * @see {@link module:chanko/channels.config|config} */ const SET_IMMEDIATE = Symbol(\"SET_IMMEDIATE\"); /** * The dispatch method option indicating that a `MessageChannel` should be used * to dispatch tasks. * * For environments that don't support `MessageChannel`, this falls back to * `{@link module:chanko/channels.SET_TIMEOUT|SET_TIMEOUT}`. * * @memberof module:chanko/channels * @type {Symbol} * @see {@link module:chanko/channels.config|config} */ const MESSAGE_CHANNEL = Symbol(\"MESSAGE_CHANNEL\"); /** * The dispatch method option indicating that `setTimeout` should be used to * dispatch tasks. * * This method is always available, but it's also always less efficient than any * other method, so it should be used as a last resort. * * @memberof module:chanko/channels * @type {Symbol} * @see {@link module:chanko/channels.config|config} */ const SET_TIMEOUT = Symbol(\"SET_TIMEOUT\"); const options = { batchSize: 1024, dispatchMethod: SET_IMMEDIATE }; let dispatcher = createDispatcher(); let running = false; let queued = true; /** * Creates and returns a function that can be used to dispatch tasks. The * function that is created depends on the currently selected `dispatchMethod` * that can be set with `{@link module:chanko/channels.config|config}`. * * @return A dispatcher function using the currently selected dispatch method. * @private */ function createDispatcher() { switch (calcDispatchMethod()) { // We prefer `setImmediate` if it's available, but it's only available in // Node and some old browsers. case SET_IMMEDIATE: return () =&gt; { if (!(queued &amp;&amp; running)) { queued = true; setImmediate(processTasks); } }; // Most modern browsers implement `MessageChannel`. This is the preferred // method in browser environments where `setImmediate` isn't available. case MESSAGE_CHANNEL: { const channel = new MessageChannel(); channel.port1.onmessage = () =&gt; processTasks(); return () =&gt; { if (!(queued &amp;&amp; running)) { queued = true; channel.port2.postMessage(0); } }; } // If all else fails, just use `setTimeout`. It's a little slower than the // other methods, but it's available everywhere. case SET_TIMEOUT: return () =&gt; { if (!(queued &amp;&amp; running)) { queued = true; setTimeout(processTasks, 0); } }; } } /** * Calculates the actual dispatch method based on the current dispatch method * setting and environmental availability. * * The dispatch method is stored raw, so this function is necessary to take * environment into account. For example, if we're running in a modern browser * (which does not have `setImmediate`), * `{@link module:chanko/channels.SET_IMMEDIATE|SET_IMMEDIATE}` can still be * recorded as the dispatch method, but this function will return * `{@link module:chanko/channels.MESSAGE_CHANNEL|MESSAGE_CHANNEL}`. * * @return {Symbol} The dispatch method to use based on setting and environment. * @private */ function calcDispatchMethod() { switch (options.dispatchMethod) { case MESSAGE_CHANNEL: if (typeof MessageChannel !== \"undefined\") { return MESSAGE_CHANNEL; } return SET_TIMEOUT; case SET_TIMEOUT: return SET_TIMEOUT; default: if (typeof setImmediate !== \"undefined\") { return SET_IMMEDIATE; } if (typeof MessageChannel !== \"undefined\") { return MESSAGE_CHANNEL; } return SET_TIMEOUT; } } /** * The heart of the dispatch process, this is the function run by the dispatch * function in order to actually run queued tasks. * * @private */ function processTasks() { running = true; queued = false; let count = 0; for (;;) { const task = dequeue(queue); if (task === EMPTY) { break; } task(); if (count &gt;= options.batchSize) { break; } count++; running = false; if (qCount(queue)) { dispatcher(); } } } /** * Creates and assigns the global dispatch function based on dispatch method * setting and environmental availability. * * @private */ function setDispatcher() { dispatcher = createDispatcher(); } /** * The configuration of the Chanko dispatcher. An object like this is returned * from the {@link module:chanko/channels.config} function, and it may also be * passed to the same function (though each property is optional in that case). * * @typedef {object} DispatcherConfig * @memberof module:chanko/channels * @property {number} batchSize The maximum number of tasks that the dispatcher * will run in a single batch. * @property {Symbol} dispatchMethod The method used to dispatch a process into * a separate line of execution. */ /** * Sets one or more of the dispatcher configuration options. * * This is advanced setting for the dispatcher that is responsible for queueing * up channel operations and processes. It is likely that this function will * never need to be called in normal operation. * * If any recognized options are specified in the options object passed to * `config`, then the option is set to the value sent in. Properties that aren't * any of these options are ignored, and any of these options that do not appear * in the passed object are left with their current values. * * @memberof module:chanko/channels * @param {Object} opts A mapping of options to their new values. Extra values * (properties that are not options) are ignored. * @param {number} [opts.batchSize] The maximum number of tasks that the * dispatcher will run in a single batch (initially, this is 1024). If the * number of pending tasks exceeds this, the remaining are not discarded. * They're simply run as part of another batch after the current batch * completes. * @param {Symbol} [opts.dispatchMethod] The method used to dispatch a process * into a separate line of execution. Possible values are * `{@link module:chanko/channels.SET_IMMEDIATE|SET_IMMEDIATE}`, * `{@link module:chanko/channels.MESSAGE_CHANNEL|MESSAGE_CHANNEL}`, or * `{@link module:chanko/channels.SET_TIMEOUT|SET_TIMEOUT}`, with the * initial being * `{@link module:chanko/channels.SET_IMMEDIATE|SET_IMMEDIATE}`. If a method * is set but is not available in that environment, then it will silently * fall back to the next method that is available. * @return {module:chanko/channels.DispatcherConfig} The configuration * settings for the dispatcher after any new values have been set. */ function config(opts = {}) { for (const key in options) { if (key in opts) { options[key] = opts[key]; if (key === \"dispatchMethod\") { setDispatcher(); } } } return Object.assign({}, options); } /** * Queues a task to be run and starts the dispatch process. * * @param {function} task A task to be queued and run the next time a batch of * tasks is run. * @private */ function dispatch(task) { enqueue(queue, task); dispatcher(); } export { SET_IMMEDIATE, MESSAGE_CHANNEL, SET_TIMEOUT, config, dispatch }; × Search results Close "},"channels_src_modules_queue.js.html":{"id":"channels_src_modules_queue.js.html","title":"Source: channels/src/modules/queue.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/queue.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * Provides an efficient general-purpose queue. * * @module chanko/queue * @private */ /** * A general purpose, highly efficient JavaScript queue. It is backed by a * JavaScript array, but it does not use `unshift` to take elements off the * array because unshift causes elements to be copied every time it's used. * Instead, a pointer is maintained that keeps track of the location of the next * element to be dequeued, and when that dequeue happens, the pointer simply * moves. When the empty space at the head of the array gets large enough, it's * removed by a single slice operation. * * Putting elements into the queue is just done with a basic `push`, which *is* * highly efficient. * * This type of queue is possible in JavaScript because JS arrays are resizable. * In languages with fixed-size arrays, a resizing operation would have to be * run each time the queue fills. * * @namespace Queue * @private */ /** * The value returned when a queue is read when it's empty. * * This special value is used because `null` and `undefined` are possible * legitimate values that can be stored in a queue. Another option is to use * some kind of `Maybe` or `Option` type, but that requires more effort on the * part of the end user to interface with. * * @type {Symbol} * @memberof module:chanko/channels */ const EMPTY = Symbol(\"EMPTY\"); /** * A marker property name to indicate that an object is in fact a queue. * * A queue has a property with this name whose readonly value is set to `true`. * This is not meant to be read except by the * `{@link module:chanko/queue~Queue.isQueue|isQueue}` function. * * @type {Symbol} * @private */ const QUEUE = Symbol(\"QUEUE\"); /** * Determines whether an object is a queue. * * @param {*} obj The object to be tested. * @return {boolean} Either `true` if the object is a queue or `false` if it is * not. */ function isQueue(obj) { return !!obj?.[QUEUE]; } /** * Creates a new queue. This queue is created empty, with a backing array of * length 0. * * @returns {module:chanko/queue~Queue} A new, empty queue. * @private */ function queue() { return Object.create(null, { store: { value: [], writable: true }, pointer: { value: 0, writable: true }, [QUEUE]: { value: true } }); } /** * Returns the number of elements stored in a queue. This may or may not equal * the length of the backing store, as there is often empty space at the head of * the backing store. * * @param {module:chanko/queue~Queue} queue The queue whose items are being * counted. * @return {number} The number of items in the queue. * @private */ function count(queue) { return queue.store.length - queue.pointer; } /** * Determines whether a queue is empty. * * @param {module:chanko/queue~Queue} queue The queue being checked for * emptiness. * @return {boolean} Either `true` if the queue is empty or `false` if it is * not. * @private */ function isEmpty(queue) { return queue.store.length === 0; } /** * Adds an item to a queue. * * @param {module:chanko/queue~Queue} queue The queue which is having an item * added to it. * @param {*} item The item being added to the queue. * @private */ function enqueue(queue, item) { queue.store.push(item); } /** * Removes an item from a queue and returns that item. If the removal causes the * amount of empty space at the head of the backing store to exceed a threshold, * that empty space is removed. * * @param {module:chanko/queue~Queue} queue The queue whose oldest item is to be * r emoved. * @return {*} The oldest stored item in the queue. */ function dequeue(queue) { if (queue.store.length === 0) { return EMPTY; } const item = queue.store[queue.pointer]; // Removes the items in the backing store before the current pointer, if there // is enough \"empty\" space before the pointer to justify it (i.e., the unused // portion is at least half as large as the used portion) if (++queue.pointer * 2 &gt;= queue.store.length) { queue.store = queue.store.slice(queue.pointer); queue.pointer = 0; } return item; } /** * Returns the next item in a queue without removing it. * * @param {module:chanko/queue~Queue} queue The queue whose oldest item is to be * peeked at. * @return {*} The oldest item stored in the queue. */ function peek(queue) { return queue.store.length === 0 ? EMPTY : queue.store[queue.pointer]; } /** * Filters out any item in a queue that does not cause the supplied predicate * function to return `true` when passed that item. This is not exactly a * general purpose queue operation, but we need it with channels that will * occasionally want to get rid of inactive handlers. * * @param {module:chanko/queue~Queue} queue The queue being filtered. * @param {function} fn The predicate function that determines whether an * element remains in the queue. */ function filter(queue, predicate) { for (let i = 0, end = count(queue); i &lt; end; i++) { const item = dequeue(queue); if (predicate(item)) { enqueue(queue, item); } } } export { EMPTY, queue, isQueue, count, isEmpty, enqueue, dequeue, peek, filter }; × Search results Close "},"channels_src_modules_process.js.html":{"id":"channels_src_modules_process.js.html","title":"Source: channels/src/modules/process.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/process.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * Provides small utility functions to make it easier to interact with async * functions as processes. * * @module chanko/process * @private */ import { timedChan, recvAsync } from \"modules/channel\"; /** * Blocks the process for the specified time (in milliseconds) and then unblocks * it. * * This implements a delay, but one that's superior to other kinds of delays * (`setTimeout`, etc.) because it blocks the process and allows the dispatcher * to allow other processes to run while this one waits. The default delay is 0, * which will release the process to allow others to run and then immediately * re-queue it. * * This function *must* be called from within an `async` function and as part of * an `await` expression. * * When this function completes and its process unblocks, the `await` expression * doesn't take on any meaningful value. The purpose of this function is simply * to delay, not to communicate any data. * * @memberof module:chanko/channels * @param {number} [delay=0] the number of milliseconds that the process will * block for. At the end of that time, the process is again eligible to be * run by the dispatcher. If this is missing or set to `0`, the process will * cede execution to the next one but immediately requeue itself to be run * again. * @return {Promise} A promise that resolves with no meaningful result when the * time has elapsed. */ function sleep(delay = 0) { return new Promise(resolve =&gt; { const ch = timedChan(delay); recvAsync(ch, resolve); }); } /** * Invokes an async function acting as a process. * * This is purely a convenience function, driven by the fact that it's necessary * to use an IIFE to invoke an anonymous async function, and that's not very * aesthetically pleasing. It does no more than invoke the passed function, but * that at least releases us from the need to put the empty parentheses after * the function definition. * * A named async function can simply be invoked (without being an IIFE) and * doesn't benefit from this convenience. * * Anonymous process without `go`: * ``` * (async () =&gt; { * ... do some process stuff here ... * })(); * ``` * Anonymous process with `go`: * ``` * go(async () =&gt; { * ... do some process stuff here ... * }); * ``` * * @memberof module:chanko/channels * @param {function} fn The async function being used as a process. * @param {...*} args Arguments that are sent to the async function when it's * invoked. * @return {Promise} The promise returned by the async function. */ function go(fn, ...args) { return fn(...args); } /** * Joins all of the provided processes into a single process, returning a * promise that wraps all of the individual processes' promises. Putting this in * an `await` statement will block until all of the processes complete. * * @memberof module:chanko/channels * @param {...function} fns Any number of async functions whose resolutions are * being waited for. * @return {Promise} A promise that resolves when all of the processes promises * resolve. */ function join(...fns) { return Promise.all(fns); } export { sleep, go, join }; × Search results Close "},"operations_src_index.js.html":{"id":"operations_src_index.js.html","title":"Source: operations/src/index.js","body":" Chanko Modules chanko/channelschanko/operations Source: operations/src/index.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * A set of utility functions that give one or more channels some extra * functionality. Each of these accept one or more * {@link module:chanko/channels.Channel} objects and then combine or manipulate * them in (hopefully) useful ways, such as merging them, splitting them, * reducing values they receive to a single value, or throttling them so that * they only produce one result in a given time period. * * @module chanko/operations */ export { map, merge, partition, pipe, split, tap, untap, untapAll } from \"modules/flow\"; export { reduce, toChannel, toArray } from \"modules/conversion\"; export { debounce, throttle } from \"modules/timing\"; /** * A function that takes a single value and, depending on whether that value * meets the function's criteria for passing, returns `true` or `false`. * * @callback Predicate * @memberof module:chanko/operations * @param {*} value The value to test. Whether or not the value passes the test * depends on the criteria established by the predicate. * @return {boolean} Either `true` if the value passes or `false` if it doesn't. */ /** * A function that maps its input(s) to an output value. It takes a variable * number of input values and calculates an output value from them. * * @callback Mapper * @memberof module:chanko/operations * @param {...*} values The input values. * @return {*} An output value calculated from the input values. */ /** * A function that integrates one of its values into the other. It's used for * reducing channel values into a single value. * * @callback Reducer * @memberof module:chanko/operations * @param {*} acc The current accumulated value. * @param {*} value The new value that needs to be integrated into the * accumulated value. * @return {*} A new accumulated value, resulting from integrating `value` into * the original accumulated value. */ × Search results Close "},"operations_src_modules_timing.js.html":{"id":"operations_src_modules_timing.js.html","title":"Source: operations/src/modules/timing.js","body":" Chanko Modules chanko/channelschanko/operations Source: operations/src/modules/timing.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * A set of channel utilities for changing the timing of inputs being put onto * the input channel. * * @module chanko/operations/timing * @private */ import { go, chan, send, select, close, CLOSED, isTimed, timedChan } from \"@chanko/channels\"; import { isNumber } from \"modules/common\"; /** * Debounces an input channel. * * Debouncing is the act of turning several input values into one. For example, * debouncing a channel driven by a `mousemove` event would cause only the final * `mousemove` event to be put onto the channel, dropping all of the other ones. * This can be desirable because `mousemove` events come in bunches, being * produced continually while the mouse is moving, and often all that we really * care about is to learn where the mouse ended up. * * This function does this by controlling which values that have been sent to * the source channel are made available on the destination channel, and when. * * The `delay` parameter determines the debounce threshold. Once the first value * is sent to the source channel, debouncing is in effect until the number of * milliseconds in `delay` passes without any other value being put onto that * channel. In other words, the delay will be refreshed if another value is sent * to the source channel before the delay elapses. After a full delay interval * passes without a value being sent to the source channel, the last value sent * becomes available on the destination channel. * * This behavior can be modified through four options: `leading`, `trailing`, * `maxDelay`, and `cancel`. * * If both `leading` and `trailing` are `true`, values will not be duplicated. * The first value put onto the source channel will be put onto the destination * channel immediately (per `leading`) and the delay will begin, but a value * will only be made available on the destination channel at the end of the * delay (per `trailing`) if *another* input value was put onto the source * channel before the delay expired. * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The source channel. * @param {(number|module:chanko/channels.Buffer)} [buffer=0] A buffer used to * create the destination channel. If this is a number, a * {@link module:chanko/channels.FixedBuffer|FixedBuffer} of that size will be * used. If this is `0` or not present, the channel will be unbuffered. * @param {number} delay The debouncing delay, in milliseconds. * @param {Object} [options={}] A set of options to further configure the * debouncing. * @param {boolean} [options.leading=false] Instead of making a value available * on the destination channel after the delay passes, the first value put * onto the source channel is made available *before* the delay begins. No * value is available on the destination channel after the delay has elapsed * (unless `trailing` is also `true`). * @param {boolean} [options.trailing=true] The default behavior, where a value * is not made available on the destination channel until the entire delay * passes without a new value being put on the source channel. * @param {number} [options.maxDelay=0] The maximum delay allowed before a value * is put onto the destination channel. Debouncing can, in theory, go on * forever as long as new input values continue to be put onto the source * channel before the delay expires. Setting this option to a positive * number sets the maximum number of milliseconds that debouncing can go on * before it's forced to end, even if in the middle of a debouncing delay. * Having debouncing end through the max delay operates exactly as if it had * ended because of lack of input; the last input is made available on the * destination channel (if `trailing` is `true`), and the next input will * trigger another debounce operation. * @param {module:chanko/channels.Channel} [options.cancel] A channel used to * signal a cancellation of the debouncing. Any value put onto this channel * will cancel the current debouncing operation, closing the output channel * and discarding any values that were waiting for the debounce threshold * timer to be sent to the output. * @return {module:chanko/channels.Channel} The newly-created destination * channel, where all of the values will be debounced from the source * channel. */ function debounce(src, buffer, delay, options) { const defaults = { leading: false, trailing: true, maxDelay: 0, cancel: chan() }; const [buf, del, opts] = isNumber(delay) ? [buffer, delay, Object.assign(defaults, options ?? {})] : [0, buffer, Object.assign(defaults, delay ?? {})]; const dst = chan(buf); const { leading, trailing, maxDelay, cancel } = opts; go(async () =&gt; { let timer = chan(); let max = chan(); let current = CLOSED; for (;;) { const { value, channel } = await select([src, timer, max, cancel]); if (channel === cancel) { close(dst); break; } if (channel === src) { if (value === CLOSED) { close(dst); break; } const timing = isTimed(timer); timer = timedChan(del); if (!timing &amp;&amp; maxDelay &gt; 0) { max = timedChan(maxDelay); } if (leading) { if (!timing) { await send(dst, value); } else { current = value; } } else if (trailing) { current = value; } } else { timer = chan(); max = chan(); if (trailing &amp;&amp; current !== CLOSED) { await send(dst, current); current === CLOSED; } } } }); return dst; } /** * Throttles an input channel. * * Throttling is the act of ensuring that something only happens once per time * interval. In this case, it means that a value sent to the source channel is * only made available to the destination channel once per a given number of * milliseconds. An example usage would be with window scroll events; these * events are nearly continuous as scrolling is happening, and perhaps we don't * want to call an expensive UI updating function every time a scroll event is * fired. We can throttle the input channel and make it only offer up the scroll * events once every 100 milliseconds, for instance. * * Throttling is effected by creating a new channel as a throttled destination * for values sent to the source channel. Values will only appear on that * destination channel once per delay interval; other values that are put onto * the source channel in the meantime are discarded. * * The `delay` parameter controls how often a value can become available on the * destination channel. When the first value is sent to the source channel, it * is immediately sent to the destination channel as well and the delay begins. * Any further values sent to the source channel during that delay are *not* * passed through; only when the delay expires is the last input value made * available on the destination channel. The delay then begins again, so that * further inputs are squelched until *that* delay passes. Throttling continues, * only allowing one value through per interval, until an entire interval passes * without input. * * This behavior can be modified by three options: `leading`, `trailing`, and * `cancel`. * * If both `leading` and `trailing` are `true`, values will not be duplicated. * The first value sent to the source channel will be put onto the destination * channel immediately (per `leading`) and the delay will begin, but a value * will only be made available on the destination channel at the end of the * delay (per `trailing`) if *another* input value was sent to the source * channel before the delay expired. * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The source channel. * @param {(number|module:chanko/channels.Buffer)} [buffer=0] A buffer used to * create the destination channel. If this is a number, a * {@link module:chanko/channels.FixedBuffer|FixedBuffer} of that size will * be used. If this is `0` or not present, the channel will be unbuffered. * @param {number} delay The throttling delay, in milliseconds. * @param {Object} [options={}] A set of options to further configure the * throttling. * @param {boolean} [options.leading=true] Makes the value that triggered the * throttling immediately available on the destination channel before * beginning the delay. If this is `false`, the first value will not be put * onto the destination channel until a full delay interval passes. * @param {boolean} [options.trailing=true] Makes the last value put onto the * source channel available on the destination channel when the delay * expires. If this is `false`, any inputs that come in during the delay are * ignored, and the next value is not put onto the destination channel until * the first input *after* the delay expires. * @param {module:chanko/channels.Channel} [options.cancel] A channel used to * signal a cancellation of the throttling. Any value put onto this channel * will cancel the current throttling operation, closing the output channel * and discarding any values that were waiting for the throttle threshold * timer to be sent to the output. * @return {module:chanko/channels.Channel}} The newly-created destination * channel, where all of the values will be throttled from the source * channel. */ function throttle(src, buffer, delay, options) { const defaults = { leading: true, trailing: true, cancel: chan() }; const [buf, del, opts] = isNumber(delay) ? [buffer, delay, Object.assign(defaults, options ?? {})] : [0, buffer, Object.assign(defaults, delay ?? {})]; const dst = chan(buf); const { leading, trailing, cancel } = opts; go(async () =&gt; { let timer = chan(); let current = CLOSED; for (;;) { const { value, channel } = await select([src, timer, cancel]); if (channel === cancel) { close(dst); break; } if (channel === src) { if (value === CLOSED) { close(dst); break; } const timing = isTimed(timer); if (!timing) { timer = timedChan(del); } if (leading) { if (!timing) { await send(dst, value); } else if (trailing) { current = value; } } else if (trailing) { current = value; } } else if (trailing &amp;&amp; current !== CLOSED) { timer = timedChan(del); await send(dst, current); current = CLOSED; } else { timer = chan(); } } }); return dst; } export { debounce, throttle }; × Search results Close "},"operations_src_modules_flow.js.html":{"id":"operations_src_modules_flow.js.html","title":"Source: operations/src/modules/flow.js","body":" Chanko Modules chanko/channelschanko/operations Source: operations/src/modules/flow.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * A set of channel operation functions for routing channels to other channels * in different ways. * * In each of these functions, the source channel will not be available to be * taken from, as all of the source channels will have their values taken by the * processes within these functions. The lone exception is `tap`, where the * regular function of the source channel will be restored if all taps are * removed. Even so, while at least one tap is in place, the source channel * cannot be taken from. * * @module chanko/operations/flow * @private */ import { go, chan, send, recv, select, sendAsync, recvAsync, close, CLOSED } from \"@chanko/channels\"; import { isNumber } from \"modules/common\"; const TAPS = Symbol(\"multitap/taps\"); /** * Pipes the values from one channel to another channel. * * This ties two channels together so that puts on the source channel can be * taken off the destination channel. This does not duplicate values in any way; * if another process takes a value off the source channel, it will never appear * on the destination channel. In most cases you will not want to take values * off a channel once it's piped to another channel, since it's difficult to * know which values will go to which channel. * * Closing either channel will break the connection between the two. If the * source channel is closed, the destination channel will by default also be * closed. However, passing `true` as the third parameter will cause the * destination channel to remain open even when the source channel is closed * (the connection is still broken however). * * Because of the ability to leave the destination channel open, a possible use * case for this function is to wrap the destination channel(s) of one of the * other flow control functions below to have a channel that survives the source * channel closing. The rest of those functions (aside from the special-case * `{@link module:chanko/operations.tap|tap}`) automatically close their * destination channels when the source channels close. * * ``` * import { go, chan, send, recv, close, isClosed } from \"@chanko/channels\"; * import { pipe } from \"@chanko/operations\"; * * const input = chan(); * const output = pipe(input, chan()); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * close(input); * }); * * go(async () =&gt; { * console.log(await recv(output)); // -&gt; 1 * console.log(await recv(output)); // -&gt; 2 * console.log(isClosed(output)); // -&gt; true * }); * ``` * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The source channel. * @param {module:chanko/channels.Channel} dest The destination channel. * @param {boolean} [keepOpen=false] A flag to indicate that the destination * channel should be kept open after the source channel closes. By default * the destination channel will close when the source channel closes. * @return {module:chanko/channels.Channel} The destination channel. */ function pipe(src, dst, keepOpen = false) { go(async () =&gt; { for (;;) { const value = await recv(src); if (value === CLOSED) { if (!keepOpen) { close(dst); } break; } if (!(await send(dst, value))) { break; } } }); return dst; } /** * Creates two new channels and routes values from a source channel to them * according to a predicate function. * * The supplied function is invoked with every value that is put onto the source * channel. Those that return `true` are routed to the first destination * channel; those that return `false` are routed to the second. * * The new channels are created by the function based on the buffer values * passed as the third and fourth parameters. If one or both of these are * missing, `null`, or `0`, the corresponding destination channel is unbuffered. * If one is a positive integer, the corresponding channel is buffered by a * fixed buffer of that size. If the parameter for a channel is a buffer, then * that buffer is used to buffer the new channel. * * Both new channels are closed when the source channel is closed. * * * ``` * import { go, chan, send, close } from \"@chanko/channels\"; * import { partition } from \"@chanko/operations\"; * * const input = chan(); * const ctrl = chan(); * const [even, odd] = partition(x =&gt; x % 2 === 0, input, 3, 3); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * await send(input, 3); * await send(input, 4); * close(input); * }); * * go(async () =&gt; { * for await (const value of even) { * console.log(value); * } * await send(ctrl); * }); * * go(async () =&gt; { * await recv(ctrl); * for await (const value of odd) { * console.log(value); * } * }); * * // The `ctrl` channel ensures that all of the values on the even channel are * // read before any of the values on the odd channel are (this is only * // possible because the output channels have buffers big enough to make sure * // that no send is blocked). * // * // -&gt; 2 * // -&gt; 4 * // -&gt; 1 * // -&gt; 3 * ``` * * @memberof module:chanko/operations * @param {module:chanko/operations.Predicate} fn A predicate function used to * test each value on the input channel. * @param {module:chanko/channels.Channel} src The source channel. * @param {(number|module:chanko/channels.Buffer)} [tBuffer=0] A buffer used to * create the destination channel which receives all values that passed the * predicate. If this is a number, a * {@link module:chanko/channels.FixedBuffer} of that size will be used. If * this is `0` or not present, the channel will be unbuffered. * @param {(number|module:chanko/channels.Buffer)} [fBuffer=0] A buffer used to * create the destination channel which receives all values that did not * pass the predicate. If this is a number, a * {@link module:chanko/channels.FixedBuffer} of that size will be used. If * this is `0` or not present, the channel will be unbuffered. * @return {module:chanko/channels.Channel[]} An array of two channels. The first * is the destination channel with all of the values that passed the * predicate, the second is the destination channel with all of the values * that did not pass the predicate. */ function partition(fn, src, tBuffer = 0, fBuffer = 0) { const tDst = chan(tBuffer); const fDst = chan(fBuffer); go(async () =&gt; { for (;;) { const value = await recv(src); if (value === CLOSED) { close(tDst); close(fDst); break; } await send(fn(value) ? tDst : fDst, value); } }); return [tDst, fDst]; } /** * Merges one or more channels into a single destination channel. * * Values are given to the destination channel as they are sent to the source * channels. If `merge` is called when there are already values on multiple * source channels, the order that they're put onto the destination channel is * random. * * The destination channel is created by the function based on the buffer value * passed as the second parameter. If this is missing, `null`, or `0`, the * destination channel will be unbuffered. If it's a positive integer, the * destination channel is buffered by a fixed buffer of that size. If the * parameter is a buffer, then that buffer is used to buffer the destination * channel. * * As each source channel closes, it is removed from the merge, leaving the * channels that are still open to continue merging. When *all* of the source * channels close, then the destination channel is closed. * * ``` * import { go, chan, send, recv } from \"@chanko/channels\"; * import { merge } from \"@chanko/operations\"; * * const input1 = chan(); * const input2 = chan(); * const input3 = chan(); * const output = merge([input1, input2, input3]); * * go(async () =&gt; { * // Because we're sending to all three channels in the same * // process, we know the order in which the values will be * // sent to the output channel; in general, we won't know this * await send(input1, 1); * await send(input2, 2); * await send(input3, 3); * }); * * go(async () =&gt; { * console.log(await recv(output)); // -&gt; 1 * console.log(await recv(output)); // -&gt; 2 * console.log(await recv(output)); // -&gt; 3 * }); * ``` * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel[]} srcs An array of source channels. * @param {(number|module:chanko/channels.Buffer)} [buffer=0] A buffer used to * create the destination channel. If this is a number, a * {@link module:chanko/channels.FixedBuffer} of that size will be used. If * this is `0` or not present, the channel will be unbuffered. * @return {module:chanko/channels.Channel} The destination channel, which will * receive all values put onto every source channel. */ function merge(srcs, buffer = 0) { const dst = chan(buffer); const inputs = srcs.slice(); go(async () =&gt; { for (;;) { if (inputs.length === 0) { break; } const { value, channel } = await select(inputs); if (value === CLOSED) { inputs.splice(inputs.indexOf(channel), 1); continue; } await send(dst, value); } close(dst); }); return dst; } /** * Splits a single channel into multiple destination channels, with each * destination channel receiving every value sent to the source channel. * * Every parameter after the first represents the buffer from a single * destination channel. Each `0` or `null` will produce an unbuffered channel, * while each positive integer will produce a channel buffered by a fixed buffer * of that size. Each buffer will produce a buffered channel backed by that * buffer. If there are no parameters after the first, then two unbuffered * channels will be produced as a default. * * When the source channel is closed, all destination channels will also be * closed. However, if destination channels are closed, they do nothing to the * source channel. * * ``` * import { go, chan, send } from \"@chanko/channels\"; * import { split } from \"@chanko/operations\"; * * const input = chan(); * const outputs = split(input, 3); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * await send(input, 3); * }); * * go(async () =&gt; { * for await (const output of outputs) { * console.log(output); * // -&gt; 1 * // -&gt; 2 * // -&gt; 3 * } * }); * ``` * * This function moves its values to the output channels asynchronously. This * means that even when using unbuffered channels, it is not necessary for all * output channels to be received from before the next send to the input channel * can complete. * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The source channel. * @param {...(number|module:chanko/channels.Buffer)} [buffers=2] The buffers * used to create the destination channels. Each entry is treated * separately. If one is a number, then a * {@link module:chanko/channels.FixedBuffer|FixedBuffer} of that size will * be used. If one is a `0`, then the corresponding channel will be * unbuffered. **Exception:** if a single number is passed, then that number * of unbuferred channels will be created. This means that the default is to * create two unbuffered channels. To create a single channel with a fixed * buffer, use `{@link chanko/channels.fixed|fixed}` explicitly. * @return {module:chanko/channels.Channel[]} An array of destination channels. */ function split(src, ...buffers) { let bfs = buffers.length === 0 ? [2] : buffers; if (bfs.length === 1 &amp;&amp; isNumber(bfs[0])) { const count = bfs[0]; bfs = []; for (let i = 0; i &lt; count; i++) { bfs.push(0); } } const dsts = bfs.map(bf =&gt; chan(bf)); const done = chan(); let count = 0; function callback() { if (--count === 0) { sendAsync(done); } } go(async () =&gt; { for (;;) { const value = await recv(src); if (value === CLOSED) { for (const dst of dsts) { close(dst); } break; } count = dsts.length; for (const dst of dsts) { sendAsync(dst, value, callback); } await recv(done); } }); return dsts; } /** * Utility function to add the ability to be tapped to a channel that is being * tapped. This will add a single property to that channel only (named * '@@multitap/taps' so as to decrease the chance of collision), but the tapping * functionality itself is provided outside the channel object. This new * property is an array of the channels tapping this channel, and it will be * removed if all taps are removed. * * @param {module:chanko/channels.Channel} src The source channel to be tapped. * @private */ function makeTap(src) { Object.defineProperty(src, TAPS, { configurable: true, writable: true, value: [] }); const done = chan(); let count = 0; function callback() { if (--count === 0) { sendAsync(done); } } go(async () =&gt; { for (;;) { const value = await recv(src); if (value === CLOSED || src[TAPS].length === 0) { delete src[TAPS]; break; } count = src[TAPS].length; for (const tap of src[TAPS]) { sendAsync(tap, value, callback); } await recv(done); } }); } /** * Taps a channel, sending all of the values sent to it to the destination * channel. * * A source channel can be tapped multiple times, and all of the tapping * (destination) channels receive each value sent to the tapped (source) * channel. * * This is different from `{@link module:chanko/operations.split|split}` in that * it's temporary. Channels can tap a channel and then untap it, multiple times, * as needed. If a source channel has all of its taps removed, then it reverts * to a normal channel, just as it was before it was tapped. * * Also unlike `{@link module:chanko/operations.split|split}`, each call can * only tap once. For multiple channels to tap a source channel, `tap` has to be * called multiple times. * * Closing either the source or any of the destination channels has no effect on * any of the other channels. * * ``` * import { go, chan, send, recv } from \"@chanko/channels\"; * import { tap } from \"@chanko/operations\"; * * const input = chan(); * const tapper = chan(); * tap(input, tapper); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * }); * * go(async () =&gt; { * console.log(await recv(tapper)); // -&gt; 1 * console.log(await recv(tapper)); // -&gt; 2 * }); * * ``` * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The channel to be tapped. * @param {module:chanko/channels.Channel} [dest] The channel tapping the source * channel. If this is not present, a new unbuffered channel will be * created. * @return {module:chanko/channels.Channel} The destination channel. This is the * same as the second argument, if present; otherwise it is the * newly-created channel tapping the source channel. */ function tap(src, dst = chan()) { if (!src[TAPS]) { makeTap(src); } if (!src[TAPS].includes(dst)) { src[TAPS].push(dst); } return dst; } /** * Untaps a previously tapping destination channel from its source channel. * * This removes a previously created tap. The destination (tapping) channel will * stop receiving the values sent to the source channel. * * If the destination channel was not, in fact, tapping the source channel, this * function will do nothing. If all taps are removed, the source channel reverts * to normal (i.e., it no longer has the tapping code applied to it and can be * taken from as normal). * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The tapped channel. * @param {module:chanko/channels.Channel} dest The channel that is tapping the * source channel that should no longer be tapping the source channel. */ function untap(src, dst) { const taps = src[TAPS]; if (taps) { const index = taps.indexOf(dst); if (index !== -1) { taps.splice(index, 1); if (taps.length === 0) { sendAsync(src); } } } } /** * Removes all taps from a source channel. * * The previously-tapped channel reverts to a normal channel, while any channels * that might have been tapping it no longer receive values from the source * channel. If the source channel had no taps, this function does nothing. * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} src The tapped channel. All taps will * be removed from this channel. */ function untapAll(src) { if (src[TAPS]) { src[TAPS] = []; sendAsync(src); } } /** * Maps the values from one or more source channels through a function, sending * the results to a new channel. * * The mapping function is given one value from each source channel, after at * least one value becomes available on every source channel. The output value * from the function is then sent to the destination channel. * * The destination channel is created by the function based on the buffer value * passed as the third parameter. If this is missing, `null`, or `0`, the * destination channel will be unbuffered. If it's a positive integer, the * destination channel is buffered by a fixed buffer of that size. If the * parameter is a buffer, then that buffer is used to buffer the destination * channel. * * Once *any* source channel is closed, the mapping ceases and the destination * channel is also closed. * * This is obviously similar to a map transducer, but unlike a transducer, this * function works with multiple input channels. This is something that a * transducer on a single channel is unable to do. * * ``` * import { go, chan, send, recv, close, isClosed } from \"@chanko/channels\"; * import { map } from \"@chanko/operations\" * * const input1 = chan(); * const input2 = chan(); * const input3 = chan(); * const output = map((x, y, z) =&gt; x + y + z, [input1, input2, input3]); * * go(async () =&gt; { * await send(input1, 1); * await send(input1, 2); * await send(input1, 3); * }); * * go(async () =&gt; { * await send(input2, 10); * await send(input2, 20); * close(input2); * }); * * go(async () =&gt; { * await send(input3, 100); * await send(input3, 200); * await send(input3, 300); * }); * * go(async () =&gt; { * console.log(await recv(output)); // -&gt; 111 * console.log(await recv(output)); // -&gt; 222 * // Output closes now because input2 closes after 2 values * console.log(isClosed(output)); // -&gt; true * }); * ``` * * @memberof module:chanko/operations * @param {module:chanko/operations.Mapper} fn The mapping function. This should * have one parameter for each source channel and return a single value. * @param {module:chanko/channels.Channel[]} srcs The source channels. * @param {(number|module:chanko/channels.Buffer)} [buffer=0] A buffer used to * create the destination channel. If this is a number, a * {@link module:chanko/channels.FixedBuffer} of that size will be used. If * this is `0` or not present, the channel will be unbuffered. * @return {module:chanko/channels.Channel} The destination channel. */ function map(fn, srcs, buffer = 0) { const dst = chan(buffer); const srclen = srcs.length; const values = []; const callbacks = []; const temp = chan(); let count; for (let i = 0; i &lt; srclen; i++) { callbacks[i] = (index =&gt; { return value =&gt; { values[index] = value; if (--count === 0) { sendAsync(temp, values.slice()); } }; })(i); } go(async () =&gt; { for (;;) { count = srclen; for (let i = 0; i &lt; srclen; i++) { recvAsync(srcs[i], callbacks[i]); } const values = await recv(temp); for (const value of values) { if (value === CLOSED) { // Once a source closes, we close the destination AND the rest of the // sources. Otherwise the sources will have nothing receiving from // them and sends to them will block forever. By closing them, sends // to them will immediately return `false` and not block. close(dst); for (const src of srcs) { close(src); } return; } } await send(dst, fn(...values)); } }); return dst; } export { pipe, partition, merge, split, tap, untap, untapAll, map }; × Search results Close "},"operations_src_modules_conversion.js.html":{"id":"operations_src_modules_conversion.js.html","title":"Source: operations/src/modules/conversion.js","body":" Chanko Modules chanko/channelschanko/operations Source: operations/src/modules/conversion.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * A set of channel utilities for converting channels into other kinds of data, * and vice versa. * * @module chanko/operations/conversion * @private */ import { go, chan, send, sendAsync, close } from \"@chanko/channels\"; /** * Creates a single value from a channel by running its values through a * reducing function. * * For every value put onto the input channel, the reducing function is called * with two parameters: the accumulator that holds the result of the reduction * so far, and the new input value. The initial value of the accumulator is the * third parameter to `reduce`. The reduction is not complete until the input * channel closes. * * This function returns a channel. When the final reduced value is produced, it * is put onto this channel, and when that value is taken from it, the channel * is closed. * * ``` * import { go, chan, send, recv, close } from \"@chanko/channels\"; * import { reduce } from \"@chanko/operations\"; * * const input = chan(); * const output = reduce((acc, value) =&gt; acc + value, input, 0); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * await send(input, 3); * close(input); * }); * * go(async () =&gt; { * const result = await recv(output); * console.log(output); // -&gt; 6 * }); * * ``` * * Note that the input channel *must* be closed at some point, or no value will * ever appear on the output channel. The closing of the channel is what * signifies that the reduction should be completed. * * @memberof module:chanko/operations * @param {module:chanko/operations.Reducer} fn The reducer function responsible * for turning the series of channel values into a single output value. * @param {module:chanko/channels.Channel} channel The channel whose values are * being reduced into a single output value. * @param {*} init The initial value to feed into the reducer function for the * first reduction step. * @return {module:chanko/channels.Channel} A channel that will, when the input * channel closes, have the reduced value put into it. When this value is * taken, the channel will automatically close. */ function reduce(fn, channel, init) { const output = chan(); go(async () =&gt; { let acc = init; for await (const value of channel) { acc = fn(acc, value); } sendAsync(output, acc, () =&gt; close(output)); }); return output; } /** * Sends all values from an iterable to the supplied channel. * * If no channel is passed to this function, a new channel is created. In * effect, this directly converts an iterable into a channel with the same * values on it. * * The channel is closed after the final iterable value is sent to it. * * This function will convert any JavaScript object that implements the iterable * protocol. In other words, if it works in a `for...of` statement, it will work * here. * * ``` * import { go, chan, recv, isClosed } from \"@chanko/channels\"; * import { toChannel } from \"@chanko/operations\"; * * const input = [1, 2, 3]; * const output = toChannel(input); * * go(async () =&gt; { * console.log(await recv(output)); // -&gt; 1 * console.log(await recv(output)); // -&gt; 2 * console.log(await recv(output)); // -&gt; 3 * console.log(isClosed(output)); // -&gt; true * }); * ``` * * @memberof module:chanko/operations * @param {iterable} iterable The iterable containing the values to be sent to * the channel. * @param {module:chanko/channels.Channel} [channel] The channel onto which to * put all of the array elements. If this is not present, a new channel will * be created. * @return {module:chanko/channels.Channel} the channel onto which the array * elements are put. This is the same as the input channel, but if no input * channel is specified, this will be a new channel. It will close when the * final value is taken from it. */ function toChannel(iterable, channel = chan(iterable.length)) { go(async () =&gt; { for (const item of iterable) { await send(channel, item); } close(channel); }); return channel; } /** * Receives all of the values from a channel and pushes them into an array. * * If no array is passed to this function, a new (empty) one is created. In * effect, this directly converts a channel into an array with the same values. * Either way, this operation cannot complete until the input channel is closed. * * This function returns a channel. When the final array is produced, it is sent * to this channel, and when that value is received from it, the channel is * closed. * * ``` * import { go, chan, send, recv, close } from \"@chanko/channels\"; * import { toArray } from \"@chanko/operations\"; * * const input = chan(); * const output = toArray(input); * * go(async () =&gt; { * await send(input, 1); * await send(input, 2); * await send(input, 3); * close(input); * }); * * go(async () =&gt; { * const result = await recv(output); * console.log(result); // -&gt; [1, 2, 3] * }); * ``` * * Note that the input channel *must* be closed at some point, or no value will * ever appear on the output channel. The closing of the channel is what * signifies that all of the values needed to make the array are now available. * * @memberof module:chanko/operations * @param {module:chanko/channels.Channel} channel The channel from which values * are received to put into the array. * @param {array} [array] The array to put the channel values into. If this is * not present, a new, empty array will be created. * @return {module:chanko/channels.Channel} A channel that will, when the input * channel closes, have the array of channel values put onto it. When this * array is received, the channel will automatically close. */ function toArray(channel, array = []) { return reduce( (acc, input) =&gt; { acc.push(input); return acc; }, channel, array ); } export { reduce, toChannel, toArray }; × Search results Close "},"channels_src_modules_protocol.js.html":{"id":"channels_src_modules_protocol.js.html","title":"Source: channels/src/modules/protocol.js","body":" Chanko Modules chanko/channelschanko/operations Source: channels/src/modules/protocol.js /** * Copyright (c) 2020 Thomas J. Otterson * * This software is released under the MIT License. * https://opensource.org/licenses/MIT */ /** * Protocols for iteration and reduction. * * The names for these protocols came from a discussion thread * ({@link https://github.com/cognitect-labs/transducers-js/issues/20}) from a * time when transducers were very much in the forefront. It's the closest thing * there is to a standard, so it was adopted here. * * These are the same symbols as available in my transducer library. They are * publicly available from there. * * @module chanko/protocol * @private */ /** * The mapping of protocol names to their respective property key names. The * values of this map will depend on whether symbols are available. * * @typedef {object} protocolMap * @property {Symbol} init The `transducer/init` protocol. This is used * to mark functions that initialize a target collection before adding items * to it. * @property {Symbol} step The `transducer/step` protocol. This is used * to mark functions that are used in the transducer's step process, where * objects are added to the target collection one at a time. * @property {Symbol} result The `transducer/result` protocol. This is * used to mark functions that take the final result of the step process and * return the final form to be output. This is optional; if the transducer * does not want to transform the final result, it should just return the * result of its chained transducer's `result` function. * @property {Symbol} reduced The `transducer/reduced` protocol. The * presence of this key on an object indicates that its transformation has * been completed. It is used internally to mark collections whose * transformations conclude before every object is iterated over (as in * `{@link xduce.take}` transducers.) It is of little use beyond transducer * authoring. * @property {Symbol} value The `transducer/value` protocol. This is * used internally to mark properties that contain the value of a reduced * transformation. It is of little use beyond transducer authoring. */ /** * The mapping of protocol names to their respective property key names. * * @type {module:chanko/protocol~protocolMap} * @private */ const protocols = Object.create(null, { init: { value: Symbol.for(\"transducer/init\") }, step: { value: Symbol.for(\"transducer/step\") }, result: { value: Symbol.for(\"transducer/result\") }, reduced: { value: Symbol.for(\"transducer/reduced\") }, value: { value: Symbol.for(\"transducer/value\") } }); export { protocols }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Chanko Modules chanko/channelschanko/operations Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Chanko Modules chanko/channelschanko/operations × Search results Close "},"module-chanko_channels.html":{"id":"module-chanko_channels.html","title":"Module: chanko/channels","body":" Chanko Modules chanko/channelschanko/operations Module: chanko/channels All of the public-facing Chanko functions are gathered here in one place to be exported as a whole. This is a completely flat list of exports, as inluding any object literals for export (which would be natural for buffers, for example) would keep tree-shaking from working right. Source: channels/src/index.js, line 8 Members &lt;static, constant&gt; CLOSED :Symbol *he value returned from a receive on a channel when that channel is closed and has no more values available. This is a special value that is returned under a certain circumstance, namely when a receive is performed on a closed channel. Because of that, it cannot be returned from a receive on an open channel. For that reason, CLOSED is the only value that cannot be sent onto a channel — it would be impossible to distinguish between a legitimate value of CLOSED and an actual closed channel. Type: Symbol Source: channels/src/modules/channel/handler.js, line 52 &lt;static, constant&gt; DEFAULT :Symbol The name of the channel returned from await select or sent to the callback in selectAsync when the default is returned as its value. This only happens when an select / selectAsync call is performed, all operations are initially blocking, and a default option is sent. The immediate response in that situation is { value: options.default, channel: DEFAULT }. Type: Symbol Source: channels/src/modules/channel/select.js, line 25 &lt;static, constant&gt; EMPTY :Symbol The value returned when a queue is read when it's empty. This special value is used because null and undefined are possible legitimate values that can be stored in a queue. Another option is to use some kind of Maybe or Option type, but that requires more effort on the part of the end user to interface with. Type: Symbol Source: channels/src/modules/queue.js, line 46 &lt;static, constant&gt; MESSAGE_CHANNEL :Symbol The dispatch method option indicating that a MessageChannel should be used to dispatch tasks. For environments that don't support MessageChannel, this falls back to SET_TIMEOUT. Type: Symbol Source: channels/src/modules/dispatcher.js, line 78 See: config &lt;static, constant&gt; SET_IMMEDIATE :Symbol The dispatch method option indicating that setImmediate should be used to dispatch tasks. This is the default option. For environments that don't support setImmediate, this falls back to MESSAGE_CHANNEL. Type: Symbol Source: channels/src/modules/dispatcher.js, line 65 See: config &lt;static, constant&gt; SET_TIMEOUT :Symbol The dispatch method option indicating that setTimeout should be used to dispatch tasks. This method is always available, but it's also always less efficient than any other method, so it should be used as a last resort. Type: Symbol Source: channels/src/modules/dispatcher.js, line 91 See: config Methods &lt;static&gt; chan( [buffer] [, options]) Creates and returns a new channel. By default this channel will be a simple unbuffered, untransformed channel, but that can be changed through options. A channel does not have any externally useful functions. It exists largely to be passed into send, recv, and select invocations, along with their non-blocking variations (sendAsync, recvAsync, and selectAsync). If a buffer value is provided, it defines what buffer should back the channel. If this is null or 0, the channel will be unbuffered. If it's a positive number, the channel will be buffered by a FixedBufferof that size. If it's a Buffer object, that object will be used as the channel's buffer. If it's missing altogether, the channel will be unbuffered unless a transducer option is provided (see below), in which case it will be a FixedBuffer of size 1. chan supports transducers by allowing a transducer function to be associated with it. This is passed as the transducer option and can only be used if the channel is buffered (otherwise an error is thrown). This transducer function must take another transducer as a parameter (allowing transformers to be chained), and it must return an object conforming to the transducer protocol. Errors in the transformation process can be handled by passing an error handler. This is a function that expects to receive an error object as a parameter and can return a value that is then put onto the channel. If this value is CLOSED, then no value will be put onto the channel upon handler completion. Parameters: Name Type Argument Description buffer number | module:chanko/channels.Buffer &lt;optional&gt; The buffer object that should back this channel. If this is a positive number, a fixed buffer of that size will be created to back the channel. If it is 0 or null, the new channel will be unbuffered. If it's not present, the new channel will be unbuffered unless there is a transducer option, in in which case it will be buffered with a size 1 FixedBuffer. options Object &lt;optional&gt; A set of options for configuring the channel's queue. Properties Name Type Argument Default Description transducer module:chanko/channels.Transducer &lt;optional&gt; A transducer to run each value through before putting it onto the channel. This function should expect one parameter (another transducer that it's chained to) and return an object that conforms to the transducer protocol. If a transducer is provided on an unbuffered channel, an error will be thrown. handler module:chanko/channels.ExceptionHandler &lt;optional&gt; An error handler that is run whenever an error occurs inside a transducer function. If that happens, this function is called with one parameter, which is the error object. The value that the handler returns (if it is not CLOSED) will be put onto the channel when the handler finishes running. maxDirty number &lt;optional&gt; 64 The maximum number of dirty operations that can be in the queue before those operations are subject to being purged. Dirty operations are those that may not be valid anymore because they were in the list of operations passed to select or selectAsync but were not chosen to run. This provides a chance for a very minor performance tweak and is best left alone. maxQueued number &lt;optional&gt; 1024 The maximum number of operations that can be queued up at the same time. This prevents infinite loops from accidentally eating up all of the available memory. timer number &lt;optional&gt; If this value is present, the channel will be a timed channel that closes automatically after this number of milliseconds. Source: channels/src/modules/channel/index.js, line 309 Returns: A new channel. Type module:chanko/channels.Channel &lt;static&gt; channel(result) A convenience function to read the channel out of a select result. This function is not necessary - after all, it's absolutely as correct to simply use result.channel instead of channel(result), but it's provided for consistency with the rest of the function-centric API. Parameters: Name Type Description result module:chanko/channels.SelectResult The result coming from a select operation. Source: channels/src/modules/channel/select.js, line 308 Returns: The channel upon which the select operation completed. Type module:chanko/channels.Channel &lt;static&gt; close(channel) Closes the channel, if it isn't already closed. This immediately returns any buffered values to pending receives. If there are no buffered values (or if they've already been taken by other receives), then all of the rest of the receives are completed with the value of CLOSED. Any pending sends are completed with the value of false. Note that the buffer is not emptied if there are still values remaining after all of the pending receives have been handled. The channel will still provide those values to any future receives, though no new values may be added to the channel. Once the buffer is depleted, any future receives will return CLOSED. Parameters: Name Type Description channel module:chanko/channels.Channel The channel to be closed. Source: channels/src/modules/channel/index.js, line 622 &lt;static&gt; config(opts) Sets one or more of the dispatcher configuration options. This is advanced setting for the dispatcher that is responsible for queueing up channel operations and processes. It is likely that this function will never need to be called in normal operation. If any recognized options are specified in the options object passed to config, then the option is set to the value sent in. Properties that aren't any of these options are ignored, and any of these options that do not appear in the passed object are left with their current values. Parameters: Name Type Description opts Object A mapping of options to their new values. Extra values (properties that are not options) are ignored. Properties Name Type Argument Description batchSize number &lt;optional&gt; The maximum number of tasks that the dispatcher will run in a single batch (initially, this is 1024). If the number of pending tasks exceeds this, the remaining are not discarded. They're simply run as part of another batch after the current batch completes. dispatchMethod Symbol &lt;optional&gt; The method used to dispatch a process into a separate line of execution. Possible values are SET_IMMEDIATE, MESSAGE_CHANNEL, or SET_TIMEOUT, with the initial being SET_IMMEDIATE. If a method is set but is not available in that environment, then it will silently fall back to the next method that is available. Source: channels/src/modules/dispatcher.js, line 269 Returns: The configuration settings for the dispatcher after any new values have been set. Type module:chanko/channels.DispatcherConfig &lt;static&gt; dropping(size) Creates a dropping buffer of the specified capacity. A dropping buffer silently drops the item being added if the buffer is already at capacity. Since adding a new item will always 'succeed' (even if it succeeds by just ignoring the add), it is never considered full and therefore a put to a channel buffered by a dropping buffer never blocks. This buffer is passed to chan, etc. to create a buffered channel. It is not meant to be used directly. Parameters: Name Type Description size number The number of items that the new buffer can hold before newest items are dropped on add. Source: channels/src/modules/buffer.js, line 174 Returns: A new dropping buffer of the specified capacity. Type module:chanko/channels.DroppingBuffer &lt;static&gt; fixed(size) Creates a fixed buffer of the specified capacity. A fixed buffer is a 'normal' buffer, one that stores and returns items on demand. While it is capable of being over-filled, that ability is not used in Chanko. A buffer that is full will cause the next put to its channel to block until at least one item is removed from the buffer. This buffer is passed to chan, etc. to create a buffered channel. It is not meant to be used directly. Parameters: Name Type Description size number The number of items that the new buffer can hold before it's full. Source: channels/src/modules/buffer.js, line 108 Returns: A new fixed buffer of the specified capacity. Type module:chanko/channels.FixedBuffer &lt;static&gt; go(fn, args) Invokes an async function acting as a process. This is purely a convenience function, driven by the fact that it's necessary to use an IIFE to invoke an anonymous async function, and that's not very aesthetically pleasing. It does no more than invoke the passed function, but that at least releases us from the need to put the empty parentheses after the function definition. A named async function can simply be invoked (without being an IIFE) and doesn't benefit from this convenience. Anonymous process without go: (async () =&gt; { ... do some process stuff here ... })(); Anonymous process with go: go(async () =&gt; { ... do some process stuff here ... }); Parameters: Name Type Argument Description fn function The async function being used as a process. args * &lt;repeatable&gt; Arguments that are sent to the async function when it's invoked. Source: channels/src/modules/process.js, line 82 Returns: The promise returned by the async function. Type Promise &lt;static&gt; isBuffered(channel) Determines whether a channel is buffered. A channel is buffered if a buffer or a number was passed as the first argument of chan or if a transducer is a part of the channel. Parameters: Name Type Description channel module:chanko/channels.Channel The channel to check. Source: channels/src/modules/channel/index.js, line 414 Returns: Either true if the channel is buffered or false if it isn't. Type boolean &lt;static&gt; isClosed(channel) Determines whether a channel is closed. A closed channel will cause any send operation to return false and any recv operation to return any buffered items that remain, followed by CLOSED. Parameters: Name Type Description channel module:chanko/channels.Channel The channel to check. Source: channels/src/modules/channel/index.js, line 398 Returns: Either true if the channel is closed or false if it isn't. Type boolean &lt;static&gt; isTimed(channel) Determines whether a channel is timed. A channel is timed if it was created either with the timer option of chan or with the timedChan function. It will automatically close after a certain period of time. Parameters: Name Type Description channel module:chanko/channels.Channel The channel to check. Source: channels/src/modules/channel/index.js, line 431 Returns: Either true if the channel is timed or false if it isn't. Type boolean &lt;static&gt; join(fns) Joins all of the provided processes into a single process, returning a promise that wraps all of the individual processes' promises. Putting this in an await statement will block until all of the processes complete. Parameters: Name Type Argument Description fns function &lt;repeatable&gt; Any number of async functions whose resolutions are being waited for. Source: channels/src/modules/process.js, line 97 Returns: A promise that resolves when all of the processes promises resolve. Type Promise &lt;static&gt; recv() Receives a value from this channel, blocking the async function until a value becomes available to be received (or until the channel closes with no more values on it to be received). This function must be called from within an async function and as part of an await expression. When receive is completed and its function unblocks, its await expression evaluates to the actual value that was received. If the target channel closed, then all of the values already placed onto it are resolved by receive as normal, and once no more values are available, the special value CLOSED is returned. Source: channels/src/modules/channel/index.js, line 554 Returns: A promise that will resolve to the value received from the channel once that receive is completed. If the channel closes without a value being made available, this will resolve to CLOSED. Type Promise &lt;static&gt; recvAsync( [callback]) Receives a value from this channel without blocking. This means that a call to receiveAsync does not go into an await expression, and it is not necessary to use it inside a async function. Rather than blocking until a value becomes available on the channel to be received, this one returns immediately and then invokes the callback (if provided) when a value becomes available. It can be regarded as a non-blocking version of recv`. While the primary use of this function is to receive values from channels in contexts where being inside an async function is impossible, it can still be used inside async functions at times when it's important that the receive doesn't block the function. The callback is a function of one parameter, and the value supplied for that parameter is the value received from the channel (either a value that was sent or CLOSED). If the callback isn't present, nothing will happen after the value is taken. Parameters: Name Type Argument Description callback module:chanko/channels.OpCallback &lt;optional&gt; A function that gets invoked when a value is made available to be received (this value may be CLOSED if the channel closes with no available value). The function can take one parameter, which is the value that is received from the channel. Source: channels/src/modules/channel/index.js, line 497 &lt;static&gt; recvOrThrow() Receives a value from a channel, blocking the async function until a value becomes available to be received (or until the channel closes with no more values on it to be received). If the received value is an error object, that error is thrown at that point. This function must be called from within an async function and as part of an await expression. It functions in every way like recv except in the case that the value on the channel is an object that has Error.prototype in its prototype chain (any built-in error, any properly-constructed custom error). If that happens, the error is thrown, which will cause the returned promise to be rejected with the error. It can then be handled up the promise chain like any other rejected promise. takeOrThrow is roughly equivalent to: const value = await recv(ch); if (Error.prototype.isPrototypeOf(value)) { throw value; } Source: channels/src/modules/channel/index.js, line 593 Returns: A promise that will resolve to the value taken from the channel once that take is completed. If the channel closes without a value being made available, this will resolve to CLOSED. If the taken value is an error, the promise will instead be rejected with the error object as the reason. Type Promise &lt;static&gt; select(operations [, options]) Completes the first operation among the provided operations that comes available, blocking the process until then. operations is an array whose elements must be channels or two-element sub-arrays of channels and values, in any combination. An operation that is a channel is a take operation on that channel. An operation that is a two-element array is a put operation on that channel using that value. Exactly one of these operations will complete, and it will be the first operation that unblocks. This function must be called from within an async function and as part of an await expression if the return value is needed. When select is completed and its process unblocks, its await expression evaluates to an object of two properties. The value property becomes exactly what would have been returned by the equivalent await put or await take operation: a boolean in the case of a put, or the taken value in the case of a take. The channel property is set to the channel where the operation actually took place. This will be equivalent to the channel in the operations array which completed first, allowing the process to unblock. If there is more than one operation already available to complete when the call to select is made, the operation with the highest priority will be the one to complete. Regularly, priority is non-deterministic (i.e., it's set randomly). However, if the options object has a priority value set to true, priority will be assigned in the order of the operations in the supplied array. If all of the operations must block (i.e., there are no pending puts for take operations, or takes for put operations), a default value may be returned. This is only done if there is a default property in the options object, and the value of that property becomes the value returned by await select. The channel is set to the special value DEFAULT. Parameters: Name Type Argument Default Description operations Array.&lt;object&gt; A collection of elements that correspond to recv and send operations. A recv operation is signified by an element that is a channel (which is the channel to be taken from). A send operation is specified by an element that is itself a two-element array, which has a channel followed by a value (which is the channel and value to be sent). options object &lt;optional&gt; {} An optional object which can change the behavior of select through two properties. Properties Name Type Argument Default Description priority boolean &lt;optional&gt; false If true, then the priority of operations to complete when more than one is immediately available is a priority according to position within the operations array (earlier positions have the higher priority). If false or not present, the priorty of operation completion is random. default * &lt;optional&gt; If set and all of the operations initially block, the select call completes immediately with the value of this option (the channel will be DEFAULT). If not set, the select call will block until one of the operations completes and that value and channel will be the ones returned. Source: channels/src/modules/channel/select.js, line 275 Returns: A promise that will resolve to an object of two properties: value will contain the value that would have been returned by the corresponding send or recv operation; and channel will be a reference to the channel that completed the operation to allow select to unblock. Type Promise.&lt;module:chanko/channels.SelectResult&gt; &lt;static&gt; selectAsync(operations, callback [, options]) Completes the first operation among the provided operations that comes available, without blocking. This means that a call to selectAsync does not go into an await expression, and it is not necessary to use it inside a process. Rather than blocking until an operation completes, this one returns immediately and then invokes the callback (if provided) as soon as one of the supplied operations completes. It can be regarded as a non-blocking version of select. This function uses an operations list that's identical to the one used by select. It's an array of values; if a value is a channel, then that operation is a take on that channel, while if it's a two-element array of channel and value, then that operation is a put of that value onto that channel. All options that are available to select are also available here. The callback is a function of one parameter, which in this case is an object with value and channel properties. Parameters: Name Type Argument Default Description operations Array.&lt;Object&gt; A collection of elements that correspond to recv and send operations. A recv operation is signified by an element that is a channel (which is the channel to be received from). A send operation is specified by an element that is itself a two-element array, which has a channel followed by a value (which is the channel and value to be sent). callback module:chanko/channels.SelectCallback A function that gets invoked when one of the operations completes. options Object &lt;optional&gt; {} An optional object which can change the behavior of selectAsync through two properties. Properties Name Type Argument Default Description priority boolean &lt;optional&gt; false If true, then the priority of operations to complete when more than one is immediately available is a priority according to position within the operations array (earlier positions have the higher priority). If false or not present, the priorty of operation completion is random. default * &lt;optional&gt; If set and all of the operations initially block, the selectAsync calls its callback immediately with the value of this option (the channel will be DEFAULT). If not set, the selectAsync call will not call its callback until one of the operations completes and that value and channel will be the ones returned. Source: channels/src/modules/channel/select.js, line 153 &lt;static&gt; send( [value]) Sends a value to a channel, blocking the async function until that value is received from the channel by a different function (or until the channel closes). A value is always sent to the channel, but if that value isn't specified by the second parameter, it is undefined. Any value may be sent to a channel, with the sole exception of the special value CLOSED. This function must be called from within an async function and as part of an await expression. When send is completed and its function unblocks, its await expression evaluates to a status boolean that indicates what caused the function to unblock. That value is true if the sent value was successfully taken by another process, or false if the unblocking happened because the target channel closed. Parameters: Name Type Argument Description value * &lt;optional&gt; The value being put onto the channel. Source: channels/src/modules/channel/index.js, line 528 Returns: A promise that will resolve to true or false depending on whether the put value is actually taken. Type Promise.&lt;boolean&gt; &lt;static&gt; sendAsync( [value] [, callback]) Sends a value to this channel without blocking. This means that a call to sendAsync does not go into an await expression, and it is not necessary to use it inside a async function. Rather than blocking until the sent value is taken by another async function, this one returns immediately and then invokes the callback (if provided) when the sent value is taken. It can be seen as a non-blocking version of send. While the primary use of this function is to send values onto channels in contexts where being inside an async function is impossible (for example, in a DOM element's event handler), it can still be used inside async functions at times when it's important to make sure that the function doesn't block from the send. The callback is a function of one parameter. The parameter that's supplied to the callback is the same as what is supplied to await send: true if the value was taken, or false if the channel was closed. If the callback isn't present, nothing will happen after the value is taken. Parameters: Name Type Argument Description value * &lt;optional&gt; The value being put onto the channel. callback module:chanko/channels.OpCallback &lt;optional&gt; A function that gets invoked either when the value is taken by another process or when the channel is closed. This function can take one parameter, which is true in the former case and false in the latter. Source: channels/src/modules/channel/index.js, line 463 &lt;static&gt; sleep( [delay]) Blocks the process for the specified time (in milliseconds) and then unblocks it. This implements a delay, but one that's superior to other kinds of delays (setTimeout, etc.) because it blocks the process and allows the dispatcher to allow other processes to run while this one waits. The default delay is 0, which will release the process to allow others to run and then immediately re-queue it. This function must be called from within an async function and as part of an await expression. When this function completes and its process unblocks, the await expression doesn't take on any meaningful value. The purpose of this function is simply to delay, not to communicate any data. Parameters: Name Type Argument Default Description delay number &lt;optional&gt; 0 the number of milliseconds that the process will block for. At the end of that time, the process is again eligible to be run by the dispatcher. If this is missing or set to 0, the process will cede execution to the next one but immediately requeue itself to be run again. Source: channels/src/modules/process.js, line 44 Returns: A promise that resolves with no meaningful result when the time has elapsed. Type Promise &lt;static&gt; sliding(size) Creates a sliding buffer of the specified capacity. A sliding buffer drops the first-added (oldest) item already in the buffer if a new item is added when the buffer is already at capacity. Since it's always capable of having items added to it, it's never considered full, and therefore a put to a channel buffered by a sliding buffer never blocks. This buffer is passed to chan, etc. to create a buffered channel. It is not meant to be used directly. Parameters: Name Type Description size number The number of items that the new buffer can hold before oldest items are dropped on add. Source: channels/src/modules/buffer.js, line 243 Returns: A new sliding buffer of the specified capacity. Type module:chanko/channels.SlidingBuffer &lt;static&gt; timedChan(delay) Creates an unbuffered, timed channel. This channel closes automatically after the supplied number of milliseconds and is the equivalent of calling chan(0, { timer: delay }). Parameters: Name Type Default Description delay number 0 The number of milliseconds after the channel is created that it will be closed automatically. Source: channels/src/modules/channel/index.js, line 362 Returns: A new timed channel. Type module:chanko/channels.Channel &lt;static&gt; transChan(transducer [, handler]) Creates a buffered channel with a transducer and optional error handler. The buffer for this channel is a FixedBuffer of size 1. This is the equivalent of chan(1, { transducer, handler }). Parameters: Name Type Argument Description transducer module:chanko/channels.Transducer The transducer used to transform values on the new channel. handler module:chanko/channels.ExceptionHandler &lt;optional&gt; An exception handler called with the error object as its only argument when an error happens inside a transducer. If this is not provided, a default handler is used that simply does nothing, including sending no output from the value that errored. Source: channels/src/modules/channel/index.js, line 382 Returns: A new channel with a transducer. Type module:chanko/channels.Channel &lt;static&gt; value(result) A convenience function to read the value out of a select result. This function is not necessary - after all, it's absolutely as correct to simply use result.value instead of value(result), but it's provided for consistency with the rest of the function-centric API. Parameters: Name Type Description result module:chanko/channels.SelectResult The result coming from a select operation. Source: channels/src/modules/channel/select.js, line 292 Returns: The value provided by the select operation. Type * Type Definitions Buffer A buffer that stores values sent to a buffered channel until a process receives them. Different buffer differ only in the way that they determine whether they are full and in what happens when a new value is added to a full buffer. Type: module:chanko/channels.FixedBuffer | module:chanko/channels.DroppingBuffer | module:chanko/channels.SlidingBuffer Source: channels/src/modules/buffer.js, line 19 Channel A channel, used by processes to communicate with one another. For each operation, the channel first tests to see if there's a corresponding operation already queued (i.e., if we're doing a send that there's a queued recv and vice versa). If there is, that corresponding operation is unblocked and both operations complete. If not, the operation is queued to wait for a corresponding operation. The process or that created the operation then blocks. The channel can be backed by a buffer, though it is not by default. If a buffer is in place, and that buffer is not full, then the process that created an operation that has to be queued is not blocked. This channel object supports transformations, assuming that they follow the protocol created by a few transducer library authors to allow them to interoperate. The support must be explicitly created because the normal method of making an object support transformations won't work here. This method is to create a new object and add the transformed values to it - but for a channel, we need to replace the values on the channel with their transformed values, in the same order even in a multi-process environment. Thus transformations happen in place. Transformations are applied before the value is queued, so even if there is a corresponding operation ready to go, the transformation still happens. Also, transformations require that the channel be buffered (this buffer is what is sent to the transformer's reduction step function); trying to create a channel with a transformer but without a buffer will result in an error being thrown. This is the object that is returned from a call to chan. However, this object is intended to be used as a value to pass to channel operation functions; it doesn't have any properties of interest to an end user. Source: channels/src/modules/channel/handler.js, line 164 DispatcherConfig The configuration of the Chanko dispatcher. An object like this is returned from the module:chanko/channels.config function, and it may also be passed to the same function (though each property is optional in that case). Type: object Properties: Name Type Description batchSize number The maximum number of tasks that the dispatcher will run in a single batch. dispatchMethod Symbol The method used to dispatch a process into a separate line of execution. Source: channels/src/modules/dispatcher.js, line 224 DroppingBuffer A buffer implementation that drops newly added items when the buffer is full. This dropping behavior is silent: the new item is simply not added to the queue. Note that this buffer is never full because it can always be added to without exceeding the size, even if that 'adding' doesn't result in a new item actually appearing in the buffer. Source: channels/src/modules/buffer.js, line 145 ExceptionHandler(err) An error handling funciton. This is used to handle exceptions thrown in async functions and in transducers. The return value of an exception handler is typically sent to a channel; if the exception happened within an async function, it will be sent to that function's output channel, and if the excpetion happened in a transducer, it will be sent to the channel to which the transducer is attached. Parameters: Name Type Description err object The error object that was thrown to cause the error to have to be handled. Source: channels/src/index.js, line 46 Returns: A value decided by the handler that will be sent to a channel. Type * FixedBuffer A buffer implementation that never discards buffered items when a new item is added. This buffer has a concept of full, but it's a soft limit. If the size of the buffer is exceeded, added items are still stored. Source: channels/src/modules/buffer.js, line 80 OpCallback(value) A callback that's run when a non-blocking channel operation completes. The value that this function receives is identical to what is returned by a blocking call: the value received from the channel for a recv, or true or false depending on the channel status for a send. Any return value from this callback is ignored. Parameters: Name Type Description value * Either the value received from the channel, or whether or not a value was successfully sent. Source: channels/src/index.js, line 61 SelectCallback(data) A callback that's run when a non-blocking select operation completes. The value that this function receives is an object with two properties: the value that the select operation completed with (either the value received from the channel in a receive operation, or true or false in a send operation), along with the channel where the operation actually happened. Any return value from this callback is ignored. Parameters: Name Type Description data module:chanko/channels.SelectResult The value returned from the select operation. Source: channels/src/index.js, line 74 SelectResult A result that comes from select operations. Properties: Name Type Description value * If the select operation resulted in a receive, this is the value received from the channel. If it resulted in a send, this is true for a successful send and false if the channel closed first. channel module:chanko/channels.Channel The channel upon which the selected operation happened. Source: channels/src/modules/channel/select.js, line 81 SlidingBuffer A buffer implementation that drops the oldest item when an item is added to a full buffer. This is very similar to DroppingBuffer; the only difference is in what happens when an item is added. In this buffer, the new item is indeed added to the buffer, but in order to keep the count of the buffer at or below its size, the oldest item in the buffer is silently dropped. Source: channels/src/modules/buffer.js, line 211 Transducer(xform) A function that transforms data and can be composed with other transducers into a single transducer. The transducers themselves are provided by other libraries; the only involvement of this librar is as a consumer of transducers. Transducers work by having step functions that are known via protocol, and it is these step functions that take a value at a time to be transformed as their arguments. The arguments to the transducers themselves are other transducers that are then composed into a single transducer, which is then returned. These values need not concern a user of ths library; just pass a transducer to chan or transChan and everything else will be handled. Parameters: Name Type Description xform module:chanko/channels.Transducer A transducer to chain this transducer to. Source: channels/src/index.js, line 88 Returns: A new transducer consisting of the composition of this one and xform. Type module:chanko/channels.Transducer × Search results Close "},"module-chanko_operations.html":{"id":"module-chanko_operations.html","title":"Module: chanko/operations","body":" Chanko Modules chanko/channelschanko/operations Module: chanko/operations A set of utility functions that give one or more channels some extra functionality. Each of these accept one or more module:chanko/channels.Channel objects and then combine or manipulate them in (hopefully) useful ways, such as merging them, splitting them, reducing values they receive to a single value, or throttling them so that they only produce one result in a given time period. Source: operations/src/index.js, line 8 Methods &lt;static&gt; debounce(src [, buffer], delay [, options]) Debounces an input channel. Debouncing is the act of turning several input values into one. For example, debouncing a channel driven by a mousemove event would cause only the final mousemove event to be put onto the channel, dropping all of the other ones. This can be desirable because mousemove events come in bunches, being produced continually while the mouse is moving, and often all that we really care about is to learn where the mouse ended up. This function does this by controlling which values that have been sent to the source channel are made available on the destination channel, and when. The delay parameter determines the debounce threshold. Once the first value is sent to the source channel, debouncing is in effect until the number of milliseconds in delay passes without any other value being put onto that channel. In other words, the delay will be refreshed if another value is sent to the source channel before the delay elapses. After a full delay interval passes without a value being sent to the source channel, the last value sent becomes available on the destination channel. This behavior can be modified through four options: leading, trailing, maxDelay, and cancel. If both leading and trailing are true, values will not be duplicated. The first value put onto the source channel will be put onto the destination channel immediately (per leading) and the delay will begin, but a value will only be made available on the destination channel at the end of the delay (per trailing) if another input value was put onto the source channel before the delay expired. Parameters: Name Type Argument Default Description src module:chanko/channels.Channel The source channel. buffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel. If this is a number, a FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. delay number The debouncing delay, in milliseconds. options Object &lt;optional&gt; {} A set of options to further configure the debouncing. Properties Name Type Argument Default Description leading boolean &lt;optional&gt; false Instead of making a value available on the destination channel after the delay passes, the first value put onto the source channel is made available before the delay begins. No value is available on the destination channel after the delay has elapsed (unless trailing is also true). trailing boolean &lt;optional&gt; true The default behavior, where a value is not made available on the destination channel until the entire delay passes without a new value being put on the source channel. maxDelay number &lt;optional&gt; 0 The maximum delay allowed before a value is put onto the destination channel. Debouncing can, in theory, go on forever as long as new input values continue to be put onto the source channel before the delay expires. Setting this option to a positive number sets the maximum number of milliseconds that debouncing can go on before it's forced to end, even if in the middle of a debouncing delay. Having debouncing end through the max delay operates exactly as if it had ended because of lack of input; the last input is made available on the destination channel (if trailing is true), and the next input will trigger another debounce operation. cancel module:chanko/channels.Channel &lt;optional&gt; A channel used to signal a cancellation of the debouncing. Any value put onto this channel will cancel the current debouncing operation, closing the output channel and discarding any values that were waiting for the debounce threshold timer to be sent to the output. Source: operations/src/modules/timing.js, line 96 Returns: The newly-created destination channel, where all of the values will be debounced from the source channel. Type module:chanko/channels.Channel &lt;static&gt; map(fn, srcs [, buffer]) Maps the values from one or more source channels through a function, sending the results to a new channel. The mapping function is given one value from each source channel, after at least one value becomes available on every source channel. The output value from the function is then sent to the destination channel. The destination channel is created by the function based on the buffer value passed as the third parameter. If this is missing, null, or 0, the destination channel will be unbuffered. If it's a positive integer, the destination channel is buffered by a fixed buffer of that size. If the parameter is a buffer, then that buffer is used to buffer the destination channel. Once any source channel is closed, the mapping ceases and the destination channel is also closed. This is obviously similar to a map transducer, but unlike a transducer, this function works with multiple input channels. This is something that a transducer on a single channel is unable to do. import { go, chan, send, recv, close, isClosed } from \"@chanko/channels\"; import { map } from \"@chanko/operations\" const input1 = chan(); const input2 = chan(); const input3 = chan(); const output = map((x, y, z) =&gt; x + y + z, [input1, input2, input3]); go(async () =&gt; { await send(input1, 1); await send(input1, 2); await send(input1, 3); }); go(async () =&gt; { await send(input2, 10); await send(input2, 20); close(input2); }); go(async () =&gt; { await send(input3, 100); await send(input3, 200); await send(input3, 300); }); go(async () =&gt; { console.log(await recv(output)); // -&gt; 111 console.log(await recv(output)); // -&gt; 222 // Output closes now because input2 closes after 2 values console.log(isClosed(output)); // -&gt; true }); Parameters: Name Type Argument Default Description fn module:chanko/operations.Mapper The mapping function. This should have one parameter for each source channel and return a single value. srcs Array.&lt;module:chanko/channels.Channel&gt; The source channels. buffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel. If this is a number, a module:chanko/channels.FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. Source: operations/src/modules/flow.js, line 595 Returns: The destination channel. Type module:chanko/channels.Channel &lt;static&gt; merge(srcs [, buffer]) Merges one or more channels into a single destination channel. Values are given to the destination channel as they are sent to the source channels. If merge is called when there are already values on multiple source channels, the order that they're put onto the destination channel is random. The destination channel is created by the function based on the buffer value passed as the second parameter. If this is missing, null, or 0, the destination channel will be unbuffered. If it's a positive integer, the destination channel is buffered by a fixed buffer of that size. If the parameter is a buffer, then that buffer is used to buffer the destination channel. As each source channel closes, it is removed from the merge, leaving the channels that are still open to continue merging. When all of the source channels close, then the destination channel is closed. import { go, chan, send, recv } from \"@chanko/channels\"; import { merge } from \"@chanko/operations\"; const input1 = chan(); const input2 = chan(); const input3 = chan(); const output = merge([input1, input2, input3]); go(async () =&gt; { // Because we're sending to all three channels in the same // process, we know the order in which the values will be // sent to the output channel; in general, we won't know this await send(input1, 1); await send(input2, 2); await send(input3, 3); }); go(async () =&gt; { console.log(await recv(output)); // -&gt; 1 console.log(await recv(output)); // -&gt; 2 console.log(await recv(output)); // -&gt; 3 }); Parameters: Name Type Argument Default Description srcs Array.&lt;module:chanko/channels.Channel&gt; An array of source channels. buffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel. If this is a number, a module:chanko/channels.FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. Source: operations/src/modules/flow.js, line 259 Returns: The destination channel, which will receive all values put onto every source channel. Type module:chanko/channels.Channel &lt;static&gt; partition(fn, src [, tBuffer] [, fBuffer]) Creates two new channels and routes values from a source channel to them according to a predicate function. The supplied function is invoked with every value that is put onto the source channel. Those that return true are routed to the first destination channel; those that return false are routed to the second. The new channels are created by the function based on the buffer values passed as the third and fourth parameters. If one or both of these are missing, null, or 0, the corresponding destination channel is unbuffered. If one is a positive integer, the corresponding channel is buffered by a fixed buffer of that size. If the parameter for a channel is a buffer, then that buffer is used to buffer the new channel. Both new channels are closed when the source channel is closed. import { go, chan, send, close } from \"@chanko/channels\"; import { partition } from \"@chanko/operations\"; const input = chan(); const ctrl = chan(); const [even, odd] = partition(x =&gt; x % 2 === 0, input, 3, 3); go(async () =&gt; { await send(input, 1); await send(input, 2); await send(input, 3); await send(input, 4); close(input); }); go(async () =&gt; { for await (const value of even) { console.log(value); } await send(ctrl); }); go(async () =&gt; { await recv(ctrl); for await (const value of odd) { console.log(value); } }); // The `ctrl` channel ensures that all of the values on the even channel are // read before any of the values on the odd channel are (this is only // possible because the output channels have buffers big enough to make sure // that no send is blocked). // // -&gt; 2 // -&gt; 4 // -&gt; 1 // -&gt; 3 Parameters: Name Type Argument Default Description fn module:chanko/operations.Predicate A predicate function used to test each value on the input channel. src module:chanko/channels.Channel The source channel. tBuffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel which receives all values that passed the predicate. If this is a number, a module:chanko/channels.FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. fBuffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel which receives all values that did not pass the predicate. If this is a number, a module:chanko/channels.FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. Source: operations/src/modules/flow.js, line 187 Returns: An array of two channels. The first is the destination channel with all of the values that passed the predicate, the second is the destination channel with all of the values that did not pass the predicate. Type Array.&lt;module:chanko/channels.Channel&gt; &lt;static&gt; pipe(src, dest [, keepOpen]) Pipes the values from one channel to another channel. This ties two channels together so that puts on the source channel can be taken off the destination channel. This does not duplicate values in any way; if another process takes a value off the source channel, it will never appear on the destination channel. In most cases you will not want to take values off a channel once it's piped to another channel, since it's difficult to know which values will go to which channel. Closing either channel will break the connection between the two. If the source channel is closed, the destination channel will by default also be closed. However, passing true as the third parameter will cause the destination channel to remain open even when the source channel is closed (the connection is still broken however). Because of the ability to leave the destination channel open, a possible use case for this function is to wrap the destination channel(s) of one of the other flow control functions below to have a channel that survives the source channel closing. The rest of those functions (aside from the special-case tap) automatically close their destination channels when the source channels close. import { go, chan, send, recv, close, isClosed } from \"@chanko/channels\"; import { pipe } from \"@chanko/operations\"; const input = chan(); const output = pipe(input, chan()); go(async () =&gt; { await send(input, 1); await send(input, 2); close(input); }); go(async () =&gt; { console.log(await recv(output)); // -&gt; 1 console.log(await recv(output)); // -&gt; 2 console.log(isClosed(output)); // -&gt; true }); Parameters: Name Type Argument Default Description src module:chanko/channels.Channel The source channel. dest module:chanko/channels.Channel The destination channel. keepOpen boolean &lt;optional&gt; false A flag to indicate that the destination channel should be kept open after the source channel closes. By default the destination channel will close when the source channel closes. Source: operations/src/modules/flow.js, line 90 Returns: The destination channel. Type module:chanko/channels.Channel &lt;static&gt; reduce(fn, channel, init) Creates a single value from a channel by running its values through a reducing function. For every value put onto the input channel, the reducing function is called with two parameters: the accumulator that holds the result of the reduction so far, and the new input value. The initial value of the accumulator is the third parameter to reduce. The reduction is not complete until the input channel closes. This function returns a channel. When the final reduced value is produced, it is put onto this channel, and when that value is taken from it, the channel is closed. import { go, chan, send, recv, close } from \"@chanko/channels\"; import { reduce } from \"@chanko/operations\"; const input = chan(); const output = reduce((acc, value) =&gt; acc + value, input, 0); go(async () =&gt; { await send(input, 1); await send(input, 2); await send(input, 3); close(input); }); go(async () =&gt; { const result = await recv(output); console.log(output); // -&gt; 6 }); Note that the input channel must be closed at some point, or no value will ever appear on the output channel. The closing of the channel is what signifies that the reduction should be completed. Parameters: Name Type Description fn module:chanko/operations.Reducer The reducer function responsible for turning the series of channel values into a single output value. channel module:chanko/channels.Channel The channel whose values are being reduced into a single output value. init * The initial value to feed into the reducer function for the first reduction step. Source: operations/src/modules/conversion.js, line 68 Returns: A channel that will, when the input channel closes, have the reduced value put into it. When this value is taken, the channel will automatically close. Type module:chanko/channels.Channel &lt;static&gt; split(src [, buffers]) Splits a single channel into multiple destination channels, with each destination channel receiving every value sent to the source channel. Every parameter after the first represents the buffer from a single destination channel. Each 0 or null will produce an unbuffered channel, while each positive integer will produce a channel buffered by a fixed buffer of that size. Each buffer will produce a buffered channel backed by that buffer. If there are no parameters after the first, then two unbuffered channels will be produced as a default. When the source channel is closed, all destination channels will also be closed. However, if destination channels are closed, they do nothing to the source channel. import { go, chan, send } from \"@chanko/channels\"; import { split } from \"@chanko/operations\"; const input = chan(); const outputs = split(input, 3); go(async () =&gt; { await send(input, 1); await send(input, 2); await send(input, 3); }); go(async () =&gt; { for await (const output of outputs) { console.log(output); // -&gt; 1 // -&gt; 2 // -&gt; 3 } }); This function moves its values to the output channels asynchronously. This means that even when using unbuffered channels, it is not necessary for all output channels to be received from before the next send to the input channel can complete. Parameters: Name Type Argument Default Description src module:chanko/channels.Channel The source channel. buffers number | module:chanko/channels.Buffer &lt;optional&gt; &lt;repeatable&gt; 2 The buffers used to create the destination channels. Each entry is treated separately. If one is a number, then a FixedBuffer of that size will be used. If one is a 0, then the corresponding channel will be unbuffered. Exception: if a single number is passed, then that number of unbuferred channels will be created. This means that the default is to create two unbuffered channels. To create a single channel with a fixed buffer, use fixed explicitly. Source: operations/src/modules/flow.js, line 337 Returns: An array of destination channels. Type Array.&lt;module:chanko/channels.Channel&gt; &lt;static&gt; tap(src [, dest]) Taps a channel, sending all of the values sent to it to the destination channel. A source channel can be tapped multiple times, and all of the tapping (destination) channels receive each value sent to the tapped (source) channel. This is different from split in that it's temporary. Channels can tap a channel and then untap it, multiple times, as needed. If a source channel has all of its taps removed, then it reverts to a normal channel, just as it was before it was tapped. Also unlike split, each call can only tap once. For multiple channels to tap a source channel, tap has to be called multiple times. Closing either the source or any of the destination channels has no effect on any of the other channels. import { go, chan, send, recv } from \"@chanko/channels\"; import { tap } from \"@chanko/operations\"; const input = chan(); const tapper = chan(); tap(input, tapper); go(async () =&gt; { await send(input, 1); await send(input, 2); }); go(async () =&gt; { console.log(await recv(tapper)); // -&gt; 1 console.log(await recv(tapper)); // -&gt; 2 }); Parameters: Name Type Argument Description src module:chanko/channels.Channel The channel to be tapped. dest module:chanko/channels.Channel &lt;optional&gt; The channel tapping the source channel. If this is not present, a new unbuffered channel will be created. Source: operations/src/modules/flow.js, line 471 Returns: The destination channel. This is the same as the second argument, if present; otherwise it is the newly-created channel tapping the source channel. Type module:chanko/channels.Channel &lt;static&gt; throttle(src [, buffer], delay [, options]) Throttles an input channel. Throttling is the act of ensuring that something only happens once per time interval. In this case, it means that a value sent to the source channel is only made available to the destination channel once per a given number of milliseconds. An example usage would be with window scroll events; these events are nearly continuous as scrolling is happening, and perhaps we don't want to call an expensive UI updating function every time a scroll event is fired. We can throttle the input channel and make it only offer up the scroll events once every 100 milliseconds, for instance. Throttling is effected by creating a new channel as a throttled destination for values sent to the source channel. Values will only appear on that destination channel once per delay interval; other values that are put onto the source channel in the meantime are discarded. The delay parameter controls how often a value can become available on the destination channel. When the first value is sent to the source channel, it is immediately sent to the destination channel as well and the delay begins. Any further values sent to the source channel during that delay are not passed through; only when the delay expires is the last input value made available on the destination channel. The delay then begins again, so that further inputs are squelched until that delay passes. Throttling continues, only allowing one value through per interval, until an entire interval passes without input. This behavior can be modified by three options: leading, trailing, and cancel. If both leading and trailing are true, values will not be duplicated. The first value sent to the source channel will be put onto the destination channel immediately (per leading) and the delay will begin, but a value will only be made available on the destination channel at the end of the delay (per trailing) if another input value was sent to the source channel before the delay expired. Parameters: Name Type Argument Default Description src module:chanko/channels.Channel The source channel. buffer number | module:chanko/channels.Buffer &lt;optional&gt; 0 A buffer used to create the destination channel. If this is a number, a FixedBuffer of that size will be used. If this is 0 or not present, the channel will be unbuffered. delay number The throttling delay, in milliseconds. options Object &lt;optional&gt; {} A set of options to further configure the throttling. Properties Name Type Argument Default Description leading boolean &lt;optional&gt; true Makes the value that triggered the throttling immediately available on the destination channel before beginning the delay. If this is false, the first value will not be put onto the destination channel until a full delay interval passes. trailing boolean &lt;optional&gt; true Makes the last value put onto the source channel available on the destination channel when the delay expires. If this is false, any inputs that come in during the delay are ignored, and the next value is not put onto the destination channel until the first input after the delay expires. cancel module:chanko/channels.Channel &lt;optional&gt; A channel used to signal a cancellation of the throttling. Any value put onto this channel will cancel the current throttling operation, closing the output channel and discarding any values that were waiting for the throttle threshold timer to be sent to the output. Source: operations/src/modules/timing.js, line 222 Returns: } The newly-created destination channel, where all of the values will be throttled from the source channel. Type module:chanko/channels.Channel &lt;static&gt; toArray(channel [, array]) Receives all of the values from a channel and pushes them into an array. If no array is passed to this function, a new (empty) one is created. In effect, this directly converts a channel into an array with the same values. Either way, this operation cannot complete until the input channel is closed. This function returns a channel. When the final array is produced, it is sent to this channel, and when that value is received from it, the channel is closed. import { go, chan, send, recv, close } from \"@chanko/channels\"; import { toArray } from \"@chanko/operations\"; const input = chan(); const output = toArray(input); go(async () =&gt; { await send(input, 1); await send(input, 2); await send(input, 3); close(input); }); go(async () =&gt; { const result = await recv(output); console.log(result); // -&gt; [1, 2, 3] }); Note that the input channel must be closed at some point, or no value will ever appear on the output channel. The closing of the channel is what signifies that all of the values needed to make the array are now available. Parameters: Name Type Argument Description channel module:chanko/channels.Channel The channel from which values are received to put into the array. array array &lt;optional&gt; The array to put the channel values into. If this is not present, a new, empty array will be created. Source: operations/src/modules/conversion.js, line 176 Returns: A channel that will, when the input channel closes, have the array of channel values put onto it. When this array is received, the channel will automatically close. Type module:chanko/channels.Channel &lt;static&gt; toChannel(iterable [, channel]) Sends all values from an iterable to the supplied channel. If no channel is passed to this function, a new channel is created. In effect, this directly converts an iterable into a channel with the same values on it. The channel is closed after the final iterable value is sent to it. This function will convert any JavaScript object that implements the iterable protocol. In other words, if it works in a for...of statement, it will work here. import { go, chan, recv, isClosed } from \"@chanko/channels\"; import { toChannel } from \"@chanko/operations\"; const input = [1, 2, 3]; const output = toChannel(input); go(async () =&gt; { console.log(await recv(output)); // -&gt; 1 console.log(await recv(output)); // -&gt; 2 console.log(await recv(output)); // -&gt; 3 console.log(isClosed(output)); // -&gt; true }); Parameters: Name Type Argument Description iterable iterable The iterable containing the values to be sent to the channel. channel module:chanko/channels.Channel &lt;optional&gt; The channel onto which to put all of the array elements. If this is not present, a new channel will be created. Source: operations/src/modules/conversion.js, line 121 Returns: the channel onto which the array elements are put. This is the same as the input channel, but if no input channel is specified, this will be a new channel. It will close when the final value is taken from it. Type module:chanko/channels.Channel &lt;static&gt; untap(src, dest) Untaps a previously tapping destination channel from its source channel. This removes a previously created tap. The destination (tapping) channel will stop receiving the values sent to the source channel. If the destination channel was not, in fact, tapping the source channel, this function will do nothing. If all taps are removed, the source channel reverts to normal (i.e., it no longer has the tapping code applied to it and can be taken from as normal). Parameters: Name Type Description src module:chanko/channels.Channel The tapped channel. dest module:chanko/channels.Channel The channel that is tapping the source channel that should no longer be tapping the source channel. Source: operations/src/modules/flow.js, line 497 &lt;static&gt; untapAll(src) Removes all taps from a source channel. The previously-tapped channel reverts to a normal channel, while any channels that might have been tapping it no longer receive values from the source channel. If the source channel had no taps, this function does nothing. Parameters: Name Type Description src module:chanko/channels.Channel The tapped channel. All taps will be removed from this channel. Source: operations/src/modules/flow.js, line 521 Type Definitions Mapper(values) A function that maps its input(s) to an output value. It takes a variable number of input values and calculates an output value from them. Parameters: Name Type Argument Description values * &lt;repeatable&gt; The input values. Source: operations/src/index.js, line 43 Returns: An output value calculated from the input values. Type * Predicate(value) A function that takes a single value and, depending on whether that value meets the function's criteria for passing, returns true or false. Parameters: Name Type Description value * The value to test. Whether or not the value passes the test depends on the criteria established by the predicate. Source: operations/src/index.js, line 32 Returns: Either true if the value passes or false if it doesn't. Type boolean Reducer(acc, value) A function that integrates one of its values into the other. It's used for reducing channel values into a single value. Parameters: Name Type Description acc * The current accumulated value. value * The new value that needs to be integrated into the accumulated value. Source: operations/src/index.js, line 53 Returns: A new accumulated value, resulting from integrating value into the original accumulated value. Type * × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
