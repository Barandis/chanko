<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>xdcore - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-csp.html">csp</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-csp.html#.chan">chan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.channel">channel</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.close">close</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.config">config</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.dropping">dropping</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.fixed">fixed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.go">go</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isBuffered">isBuffered</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isClosed">isClosed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isTimed">isTimed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.join">join</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recv">recv</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recvAsync">recvAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recvOrThrow">recvOrThrow</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.select">select</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.selectAsync">selectAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.send">send</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sendAsync">sendAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sleep">sleep</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sliding">sliding</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.timedChan">timedChan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.transChan">transChan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.value">value</a></li></ul></li><li><a href="module-csp-ops.html">csp-ops</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.debounce">debounce</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.map">map</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.merge">merge</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.partition">partition</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.pipe">pipe</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.split">split</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.tap">tap</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.throttle">throttle</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.toArray">toArray</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.toChannel">toChannel</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.untap">untap</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.untapAll">untapAll</a></li></ul></li><li><a href="module-xdcore.html">xdcore</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-xdcore.html#.complete">complete</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.ensureCompleted">ensureCompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.ensureUncompleted">ensureUncompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isArray">isArray</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isCompleted">isCompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isFunction">isFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isGeneratorFunction">isGeneratorFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isImplemented">isImplemented</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isIterable">isIterable</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isNumber">isNumber</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isObject">isObject</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isString">isString</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.iterator">iterator</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toFunction">toFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toReducer">toReducer</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toTransducer">toTransducer</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.uncomplete">uncomplete</a></li></ul></li><li><a href="module-xduce.html">xduce</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-xduce.html#.asArray">asArray</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asIterator">asIterator</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asObject">asObject</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asString">asString</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.complement">complement</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.compose">compose</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.identity">identity</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.into">into</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.key">key</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.kv">kv</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.repeat">repeat</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.sequence">sequence</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.transduce">transduce</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.value">value</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Iterable.html">Iterable</a></li><li><a href="external-Iterator.html">Iterator</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">xdcore</h1>
    

    




<section>

<header>
    
        
            
        
    
</header>

<article>
    
        <div class="container-overview">
        
            
                <div class="description usertext"><p>The central module for the transducer engine.</p>
<p>All of the functions in this module deal directly with transducers. But
first, let's talk about the protocols that are going to be referred to
throughout many of the function discussions.</p>
<h2>Protocols</h2>
<p>One of the key selling points for transducers is that the same transducer can
be used on any type of collection. Rather than having to write a new <code>map</code>
function (for example) for every kind of collection - one for an array, one
for a string, one for an iterator, etc. - there is a single <code>map</code> transducer
that will work with all of them, and potentially with <em>any</em> kind of
collection. This is possible implementing <em>protocols</em> on the collections.</p>
<p>A protocol in JavaScript is much like an interface in languages like Java and
C#. It is a commitment to providing a certain functionality under a certain
name. ES2015 has seen the introduction of an <code>iterator</code> protocol, for
example, and language support for it (the new <code>for...of</code> loop can work with
any object that correctly implements the <code>iterator</code> protocol).</p>
<p>To support transduction, Xduce expects collections to implement four
protocols.</p>
<ul>
<li><code>iterator</code>: a function that returns an iterator (this one is built in to
ES6 JavaScript)</li>
<li><code>transducer/init</code>: a function that returns a new, empty instance of the
output collection</li>
<li><code>transducer/step</code>: a function that takes an accumulator (the result of the
reduction so far) and the next input value, and then returns the
accumulator with the next input value added to it</li>
<li><code>transducer/result</code>: a function that takes the reduced collection and
returns the final output collection</li>
</ul>
<p><code>iterator</code> is the built-in JavaScript protocol. When called, it is expected
to return an iterator over the implementing collection. This iterator is an
object that has a <code>next</code> function. Each call to <code>next</code> is expected to return
an object with <code>value</code> and <code>done</code> properties, which respectively hold the
next value of the iterator and a boolean to indicate whether the iteration
has reached its end. (This is a simplified explanation; see
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">this MDN page</a>
for more detailed information.)</p>
<p><code>transducer/init</code> (referred to from now on as <code>init</code>) should be a function
that takes no parameters and returns a new, empty instance of the output
collection. This is the function that defines how to create a new collection
of the correct type.</p>
<p><code>transducer/step</code> (referred to from now on as <code>step</code>) should be a function
that takes two parameters. These parameters are the result of the reduction
so far (and so is a collection of the output type) and the next value from
the input collection. It must return the new reduction result, with the next
value incorporated into it. This is the function that defines how reduce a
value onto the collection.</p>
<p><code>transducer/result</code> (referred to from now on as <code>result</code>) should be a
function that takes one parameter, which is the fully reduced collection. It
should return the final output collection. This affords a chance to make any
last-minute adjustments to the reduced collection before returning it.</p>
<p>Arrays, strings, and objects are all given support for all of these
protocols. Other collections will have to provide their own (though it should
be noted that since <code>iterator</code> is built-in, many third-party collections will
already implement this protocol). As an example, let's add transducer support
to a third-party collection, the <code>Immutable.List</code> collection from
<a href="https://facebook.github.io/immutable-js/">immutable-js</a>.</p>
<pre class="prettyprint source"><code>Immutable.List.prototype[protocols.init] = () => Immutable.List().asMutable();
Immutable.List.prototype[protocols.step] = (acc, input) => acc.push(input);
Immutable.List.prototype[protocols.result] = (value) => value.asImmutable();
</code></pre>
<p><code>Immutable.List</code> already implements <code>iterator</code>, so we don't have to do it
ourselves.</p>
<p>The <code>init</code> function returns an empty mutable list. This is important for
immutable-js because its default lists are immutable, and immutable lists
mean that a new list has to be created with every reduction step. It would
work fine, but it's quite inefficient.</p>
<p>The <code>step</code> function adds the next value to the already-created list.
<code>Immutable.List</code> provides a <code>push</code> function that works like an array's
<code>push</code>, except that it returns the new list with the value pushed onto it.
This is perfect for our <code>step</code> function.</p>
<p>The <code>result</code> function converts the now-finished mutable list into an
immutable one, which is what's going to be expected if we're transducing
something into an <code>Immutable.List</code>. In most cases, <code>result</code> doesn't have to
do any work, but since we're creating an intermediate representation of our
collection type here, this lets us create the collection that we actually
want to output. (Without <code>result</code>, we would have to use immutable lists all
the way through, creating a new one with each <code>step</code> function, since we
wouldn't be able to make this converstion at the end.)</p>
<p>With those protocols implemented on the prototype, <code>Immutable.List</code>
collections can now support any transduction we can offer.</p>
<h3>Protocols</h3>
<p>After talking a lot about protocols and showing how they're properties added
to an object, it's probably pretty obvious that there's been no mention of
what the actual names of those properties are. That's what
<code>protocols</code> is for.</p>
<p>The best way to use these keys can be seen in the immutable-js example above.
Instead of worrying about the name of the key for the <code>init</code> protocol, the
value of <code>protocols.init</code> is used.</p>
<p><code>protocols</code> defines these protocol
property names.</p>
<ul>
<li><code>init</code></li>
<li><code>step</code></li>
<li><code>result</code></li>
<li><code>reduced</code>: used internally to mark a collection as already reduced</li>
<li><code>value</code>: used internally to provide the actual value of a reduced
collection</li>
</ul>
<p>The final two values don't have a lot of use outside the library unless
you're writing your own transducers.</p>
<h2>How Objects Are Treated</h2>
<p>Objects bear some thought because regularly, they aren't candidates for
iteration (and therefore for transduction in general). They don't have a very
straightforward idea of order, and they have <em>two</em> pieces of data (key and
value) for every element instead of one. Yet it's undeniable that at least
for most transformations, being able to apply them to objects would be quite
handy.</p>
<p>For that reason, special support is provided end-to-end for objects.</p>
<h3>Object iteration</h3>
<p>Iterating over an object will produce one object per property of the original
object. An order is imposed; by default, this order the same as the ordering
of keys in post-ES6 Javascript:</p>
<ol>
<li>Keys that are integers, in ascending numerical order</li>
<li>All other string keys, in the order in which they were added to the object</li>
<li>All symbol keys, in the order in which they were added to the object</li>
</ol>
<p>The <code>iterator</code> function can be passed a
sorting function that can sort keys in any other way.</p>
<p>The result of the iteration, is a set of objects each with a single property,
one for each enumerable own property on the original object. The standard
ordering for objects (from ES6 onward) is as follows:</p>
<h3>Transforming objects</h3>
<p>While iterating over objects in this way is straightforward, the syntax of
objects makes it ugly to transform them in this form. Here's an example of a
transformation function that makes the object's keys upper-case and adds one
to each of the values:</p>
<pre class="prettyprint source"><code>function transform(obj) {
  const key = Object.keys(obj)[0];
  const value = obj[key];
  return { [key.toUpperCase()]: value + 1 };
}
</code></pre>
<p>A helper function named <code>property</code> can
improve this by handling the boilerplate.</p>
<pre class="prettyprint source"><code>function improvedTransform(obj) {
  const {k, v} = property(obj);
  return { [k.toUpperCase()]: v + 1 };
}
</code></pre>
<h3>Reducing objects</h3>
<p>The built-in reducers (for arrays, objects, strings, and iterators)
understand these single-property objects and reduce them in the proper manner
without any further work.</p>
<p>That's it for object-object reduction. Converting between objects and other
types is another matter.</p>
<p>Every transducer function except for
<code>sequence</code> is capable of turning an
object into a different type of collection, turning a different type of
collection into an object, or both. Objects are different because they're the
only &quot;collections&quot; that have two different pieces of data per element.
Because of this, we have to have a strategy on how to move from one to
another.</p>
<p>Transducing an object into a different type is generally pretty easy. If an
object is converted into an array, for instance, the array elements will each
be single-property objects, one per property of the original object.</p>
<p>Strings are a different story, since encoding a single-property object to a
string isn't possible (because every &quot;element&quot; of a string has to be a single
character). Strings that are produced from objects will instead just be the
object values, concatenated. Because objects are iterated in a particular
order, this conversion will always produce the same string, but except in
some very specific cases there really isn't a lot of use for this conversion.</p>
<pre class="prettyprint source"><code>const obj = {a: 1, b: 2};

let result = asArray(obj);
// result = [{a: 1}, {b: 2}]

result = asIterator(obj);
// result is an iterator with two values: {a: 1} and {b: 2}

result = into(Immutable.List(), obj)
// result is an immutable list with two elements: {a: 1} and {b: 2}

result = asString(obj);
// result is '12'
</code></pre>
<p>The opposite conversion depends on the values inside the collections. If
those values are objects, then the result is an object with all of the
objects combined (if more than one has the same key, the last one is the one
that's kept). Otherwise, keys are created for each of the elements, starting
with <code>0</code> and increasing from there.</p>
<p>This means that converting an object to any non-string collection and back
produces the original object.</p>
<pre class="prettyprint source"><code>let result = asObject([{a: 1}, {b: 2}]);
// result = {a: 1, b: 2}

result = asObject([1, 2, 3]);
// result = {0: 1, 1: 2, 2: 3}

result = asObject('hello');
// result = {0: 'h', 1: 'e', 2: 'l', 3: 'l', 4: 'o'}
</code></pre></div>
            

            
                




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line7">line 7</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>
































            
        
        </div>
    

    

    

    
    
    

     

    

    
        <h3 class="subsection-title">Members</h3>

        
            
<h4 class="name" id=".protocols"><span class="type-signature">(static, constant) </span>protocols<span class="type-signature"> :<a href="module-xdcore.html#.ProtocolMap">module:xdcore.ProtocolMap</a></span></h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line51">line 51</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The mapping of protocol names to their respective property key names.</p>
</div>



    <h5>Type:</h5>
    <ul>
        <li>
            
<span class="param-type"><a href="module-xdcore.html#.ProtocolMap">module:xdcore.ProtocolMap</a></span>


        </li>
    </ul>






        
    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".complete"><span class="type-signature">(static) </span>complete<span class="signature">(value)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.CompletedValue">module:xdcore.CompletedValue</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line327">line 327</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Marks a value as complete.</p>
<p>This is done by wrapping the value. This means three things: first, a
complete object may be marked as complete again; second, a complete value
isn't usable without being uncompleted first; and third any type of value
(including <code>undefined</code>) may be marked as complete.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be completed.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A completed version of the provided
value. This effect is achieved by wrapping the value in a marker object.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.CompletedValue">module:xdcore.CompletedValue</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".ensureCompleted"><span class="type-signature">(static) </span>ensureCompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line375">line 375</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Makes sure that a value is marked as complete; if it is not, it will be
marked as complete.</p>
<p>This differs from <a href="module-xdcore.html#.complete">complete</a> in that if the
value is already complete, this function won't complete it again. Therefore
thus function can't be used to make a value complete multiple times.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be completed.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>If the value is already complete, then the value is simply
returned. Otherwise, a completed version of the value is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".ensureUncompleted"><span class="type-signature">(static) </span>ensureUncompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line391">line 391</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Removes the complete status from a value, as long as it actually is complete.</p>
<p>This does a check to make sure the value passed in actually is complete. If
it isn't, the value itself is returned. It's meant to be used when the
completed status is uncertain.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The complete value to be uncompleted.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>If the value is already uncompleted, the value is simply
returned. Otherwise an uncompleted version of the value is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isArray"><span class="type-signature">(static) </span>isArray<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line118">line 118</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is an array.</p>
<p>This function merely delegates to <code>Array.isArray</code>. It is provided for
consistency in calling style only.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is an array.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is an array or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isCompleted"><span class="type-signature">(static) </span>isCompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line358">line 358</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is marked as complete.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to test for its complete status.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the value is completed, or <code>false</code> if it
is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isFunction"><span class="type-signature">(static) </span>isFunction<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line33">line 33</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a function.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a function or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isGeneratorFunction"><span class="type-signature">(static) </span>isGeneratorFunction<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line45">line 45</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a generator function.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a generator function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a generator function or
<code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isImplemented"><span class="type-signature">(static) </span>isImplemented<span class="signature">(obj, protocol)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line92">line 92</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a particular protocol is implemented by a value. The
possible values for <code>protocol</code> are the following, representing the two
built-in iterator protocols and the five custom transducer protocols:</p>
<ul>
<li><code>iterator</code></li>
<li><code>asyncItrerator</code></li>
<li><code>init</code></li>
<li><code>step</code></li>
<li><code>result</code></li>
<li><code>completed</code></li>
<li><code>value</code></li>
</ul>
<p>Any of these will result in <code>true</code> if the object in question has a property
that matches the one necessary to implement the protocol. Further, any of
the properties other than <code>completed</code> and <code>step</code> must be functions.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>obj</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last"><p>The object to check for protocol implementation.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>protocol</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>The name of the protocol to check for.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the object supports the named protocol or
<code>false</code> if it does not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isIterable"><span class="type-signature">(static) </span>isIterable<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_iteration.js.html">xdcore/src/modules/iteration.js</a>, <a href="xdcore_src_modules_iteration.js.html#line173">line 173</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether the passed object is iterable, in terms of what 'iterable'
means to this library. In other words, values implementing the <code>iterable</code>
protocol and plain objects return <code>true</code>, while everything else returns
<code>false</code>. This does not return <code>true</code> for functions even though
<a href="module-xdcore.html#.iterator">iterator</a> can produce an iterator for them,
because not all functions work well with
<a href="module-xdcore.html#.iterator">iterator</a>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to test for iterability.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the value is iterable
(<code><a href="module-xdcore.html#.iterator">iterator</a></code> will return an iterator for
it) or <code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isNumber"><span class="type-signature">(static) </span>isNumber<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line100">line 100</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a concrete number.</p>
<p>This function will return <code>true</code> for any number literal or instance of
<code>Number</code> except for <code>Infinity</code> or <code>NaN</code>. It will return <code>false</code> for strings
that happen to also be numbers; the value must be an actual <code>Number</code> instance
or number literal to return <code>true</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a number.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a finite number (not
including string representations of numbers) or <code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isObject"><span class="type-signature">(static) </span>isObject<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line64">line 64</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a plain object.</p>
<p>This function returns <code>false</code> if the value is any other sort of built-in
object (such as an array or a string). It also returns <code>false</code> for any object
that is created by a constructor that is not <code>Object</code>'s constructor, meaning
that &quot;instances&quot; of custom &quot;classes&quot; will return <code>false</code>. Therefore it's only
going to return <code>true</code> for literal objects or those created with
<code>Object.create()</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a plain object.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a plain object or
<code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isString"><span class="type-signature">(static) </span>isString<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line114">line 114</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a string.</p>
<p>Literal strings will return <code>true</code>, as will instances of the <code>String</code> object.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a string.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a string or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".iterator"><span class="type-signature">(static) </span>iterator<span class="signature">(value)</span><span class="type-signature"> &rarr; {<a href="external-Iterator.html">external:Iterator</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_iteration.js.html">xdcore/src/modules/iteration.js</a>, <a href="xdcore_src_modules_iteration.js.html#line144">line 144</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an iterator over the provided value. The form of the iteration
depends on what kind of value is being iterated over.</p>
<p>If the value is a collection implementing the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol">iterable protocol</a> (arrays,
strings, generators, or a custom object supporting the protocol) then the
produced iterator will be as expected: an object that implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">iterator protocol</a> by providing a <code>next</code> function that returns each
collection value in turn.</p>
<pre class="prettyprint source"><code>const iter = iterator([1, 2, 3]);
console.log(iter.next().value);   // -> 1
console.log(iter.next().value);   // -> 2
console.log(iter.next().value);   // -> 3
console.log(iter.next().done);    // -> true
</code></pre>
<p>Special support is provided for two types that are not normally iterable:
objects and functions.</p>
<p>Objects result in an iterator that produces a single-property object for
every key/value pair in the supplied object. The <a href="https://2ality.com/2015/10/property-traversal-order-es6.html">order of iteration</a> is
the same as it is for objects post-ES2015:</p>
<ol>
<li>String keys that are integer indices in ascending numerical order</li>
<li>All other string keys in the order in which they were added to the object</li>
<li>All symbol keys in the order in which they were added to the object</li>
</ol>
<pre class="prettyprint source"><code>const obj = {
  [Symbol(&quot;first&quot;)]: true,
  02: true,
  10: true,
  01: true,
  2: true,
  [Symbol(&quot;second&quot;)]: true
};
const iter = iterator(obj);
console.log(iter.next().value);   // -> { '2': true }
console.log(iter.next().value);   // -> { '10': true }
console.log(iter.next().value);   // -> { '02': true }
console.log(iter.next().value);   // -> { '01': true }
console.log(iter.next().value);   // -> { [Symbol('first')]: true }
console.log(iter.next().value);   // -> { [Symbol('second')]: true }
console.log(iter.next().done);    // -> true
</code></pre>
<p>Functions are run each time the iterator's <code>next</code> method is called, and the
return value of the function is supplied as the iterator's value at that
point.</p>
<p>This function is provided two arguments: the zero-based index of that
iteration, and the value produced by the last invocation of the iterator. The
last value is <code>undefined</code> on the first pass, but a default parameter on the
function can define the first pass value to be whatever is needed.</p>
<pre class="prettyprint source"><code>const fn = (index, last = 1) => last * (index + 1);
const iter = iterator(fn);
console.log(iter.next().value);   // -> 1
console.log(iter.next().value);   // -> 2
console.log(iter.next().value);   // -> 6
console.log(iter.next().value);   // -> 24
console.log(iter.next().value);   // -> 120
</code></pre>
<p>If the input value is neither iterable, object, or function, then the result
will be <code>null</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>
|

<span class="param-type"><a href="module-xdcore.html#.IterableFunction">module:xdcore.IterableFunction</a></span>
|

<span class="param-type"><a href="external-Iterable.html">external:Iterable</a></span>


            
            </td>

            

            

            <td class="description last"><p>The value to create an iterator over.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator over <code>value</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="external-Iterator.html">external:Iterator</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".reduce"><span class="type-signature">(static) </span>reduce<span class="signature">(collection, reducer, init)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line434">line 434</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces the elements of the input collection through a reducer into an output
collection.</p>
<p>This is the lowest-level of the transduction functions. In fact, this one is
so low-level that it doesn't have a lot of use in normal operation. It's more
useful for writing your own transformation functions.</p>
<p><code>reduce</code> doesn't assume that there's even a transformation. It requires an
initial collection and a reducer object that is matched to that initial
collection. The reducer object must implement the <code>step</code> and <code>result</code>
protocols, which instruct <code>reduce</code> on how to build up the collection. The
reducer may implement a transformation as well, but all that's important here
is that it can do the reduction.</p>
<p>The input collection need only implement <code>iterable</code>. It is not necessary for
the input and output collections to be of the same type; as long as the input
implements <code>iterable</code> and the reducer implements <code>step</code> and <code>result</code>
appropriate to the type of the <code>init</code> collection, then any translation
between collection types can occur.</p>
<p>The normal course of operation will be to call
<a href="module-xduce.html#.transduce">transduce</a> instead, as that function makes it
easy to combine transformations with reductions and can optionally figure out
the initial collection itself.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>collection</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The input collection. The only requirement of this
collection is that it implement the <code>iterable</code> protocol. Special support
is provided by the library for objects, so they can be used as well.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>An object that implements the
<code>step</code> and <code>result</code> protocols. This object must know how to produce an
output collection through those protocol functions.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>init</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>a collection of the same type as the output collection. It
need not be empty; if it is not, the existing elements are retained as
the input collection is reduced into it.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new collection, consisting of the <code>init</code> collection with all of
the elements of the <code>collection</code> collection reduced into it.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toFunction"><span class="type-signature">(static) </span>toFunction<span class="signature">(transducer, reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line296">line 296</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a reducer function from a transducer function and a reducer.</p>
<p>This produces a function that's suitable for being passed into other
libraries' reduce functions, such as JavaScript's <code>Array.prototype.reduce</code> or
Lodash's <code>_.reduce</code>. It requires both a transducer <em>and</em> a reducer because
reduction functions for those libraries must know how to reduce as well as
how to transform. The reducer can be a standard reducer object like the ones
sent to <code><a href="module-xdcore.html#.reduce">reduce</a></code>, or it can be a plain function
that takes two parameters and returns the result of reducing the second
parameter into the first (i.e., a reducer function).</p>
<p>If there is no need for a transformation, then pass in the
<code><a href="module-xduce.html#.identity">identity</a></code> transducer.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>transducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.TransducerFunction">module:xdcore.TransducerFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A transducer function
that wraps a transducer object whose <code>step</code> function will be used as a
reducer function.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>
|

<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
reducer that knows how to reduce values into an output collection. This
can either be a reducing function or a reducer object whose <code>step</code>
function knows how to perform this reduction.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A reducer function that will transform
elements via the transducer function and then reduce them into whatever
kind of collection the reducer implements.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toReducer"><span class="type-signature">(static) </span>toReducer<span class="signature">(collection)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line194">line 194</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a reducer object from a function or from a reducible type (array,
object, string, or object implementing the reducer protocols).</p>
<p>To create a reducer for arrays, objects, or strings, simply pass an empty
version of that collection to this function (e.g., <code>toReducer([])</code>).</p>
<p>The notable use for this function though is to turn a reduction function into
a reducer object. The function is a function of two parameters, an
accumulator and a value, and returns the accumulator with the value in it.
This is exactly the same kind of function that is passed to reduction
functions like JavaScript's <code>Array.prototype.reduce</code> and Lodash's <code>_.reduce</code>.</p>
<p>Note in particular that the output of this reducer does not need to be a
collection. It can be anything. While transducing normally involves
transforming one collection into another, it need not be so. For example,
here is a reducer that will result in summing of the collection values.</p>
<pre class="prettyprint source"><code>import { toReducer, reduce } from &quot;@chanko/xdcore&quot;;

const sumReducer = toReducer((acc, input) => acc + input);
const sum = reduce([1, 2, 3, 4, 5], sumReducer, 0);
console.log(sum);   // -> 15
</code></pre>
<p>This can be combined with transducers as well, as in this calculation of the
sum of the <em>squares</em> of the collection values.</p>
<pre class="prettyprint source"><code>import { toReducer } from &quot;@chanko/xdcore&quot;;
import { transduce, map } from &quot;@chanko/xduce&quot;;

const sumReducer = toReducer((acc, input) => acc + input);
const sum = transduce([1, 2, 3, 4, 5], map(x => x * x), sumReducer, 0);
console.log(sum);   // -> 55
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>collection</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>
|

<span class="param-type">object</span>
|

<span class="param-type">function</span>
|

<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
reducible collection or a reducer function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An object containing protocol
properties for <code>init</code>, <code>step</code>, and <code>result</code>. This object is suitable for
use as a reducer object (one provided to
<code><a href="module-xdcore.html#.reduce">reduce</a></code>). If the provided collection is not
reducible, all of the properties of this object will be <code>null</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toTransducer"><span class="type-signature">(static) </span>toTransducer<span class="signature">(fn, reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line255">line 255</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a transducer object from a function and a reducer object.</p>
<p>This is similar to <a href="module-xdcore.html#.toReducer">toReducer</a> except in two
respects:</p>
<ol>
<li>It only accepts a reducer function, not a reducer object</li>
<li>It chains to another reducer object</li>
</ol>
<p>This function applies the given function as the <code>step</code> function of the
returned transducer, and the <code>init</code> and <code>result</code> functions simply call the
same functions in the next reducer object. This is precisely what <em>most</em>
transducers want; <code>init</code> and <code>result</code> functions are normally handled by the
reducer at the end of the transducer chain. In the rare case when an <code>init</code>
or <code>result</code> function must do more than simply chain, this function will not
work. Generally the transducer object is created manually in that case.</p>
<p>This function does not automatically chain the <code>step</code> function to the next
one down the line, as that can be done in any number of different ways. Thus
the function itself should call the <code>step</code> function in <code>reducer</code> in whatever
way is appropriate.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>The step function for the transducer.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>The next transducer object in
the chain.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new transducer, chaining the
supplied function to the supplied transducer.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".uncomplete"><span class="type-signature">(static) </span>uncomplete<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line346">line 346</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Removes the complete status from a completed value.</p>
<p>This function is intended to be used when it's certain that a value is
already marked as complete. If it is not, <code>undefined</code> will be returned
instead of the value.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be uncompleted.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An uncompleted version of the provided value. If the value was
not complete in the first place, <code>undefined</code> will be returned instead.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
    

    
        <h3 class="subsection-title">Type Definitions</h3>

        
                
<h4 class="name" id=".CompletedValue">CompletedValue</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line302">line 302</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>Symbol.for("completed")</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last"><p>A marker property to indicate
that this is, in fact, a wrapped completed value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("value")</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The wrapped value.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>A completed value. This is a wrapper around the actual value, which is
retained as one of the properties, along with a marker property to show that
this is a wrapped value.</p>
</div>








            
                

    

    <h4 class="name" id=".InitFunction"><span class="type-signature"></span>InitFunction<span class="signature">()</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line307">line 307</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that, when called, produces a new, empty collection of whatever
type is being worked with.</p>
</div>

























<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new, empty representative of the collection.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                

    

    <h4 class="name" id=".IterableFunction"><span class="type-signature"></span>IterableFunction<span class="signature">(index, last)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line291">line 291</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that can have an iterator created for it.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>index</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>The index for the iteration. This is <code>0</code> the first
time the function is called and increases by 1 for each call
thereafter.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>last</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The return value of the function when it was called on the
previous iteration. If this is the first call to the function, then
this value will be <code>undefined</code>, meaning that the function can set a
default value for that first pass.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The return value of the function, which will be the value for
that iteration.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                
<h4 class="name" id=".ProtocolMap">ProtocolMap</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line17">line 17</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>init</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/init</code> protocol. This is used to mark
functions that initialize a target collection before adding items to it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/step</code> protocol. This is used to mark
functions that are used in the reducer's step process, where objects are
added to the target collection one at a time.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>result</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/result</code> protocol. This is used to mark
functions that take the final result of the step process and return the
final form to be output. This is optional; if the reducer does not want
to transform the final result, it should just return the result of its
chained reducer's <code>result</code> function.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reduced</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/completed</code> protocol. The presence of
this key on an object indicates that its transformation has been
completed. It is used internally to mark collections whose
transformations conclude before every object is iterated over (as in
<code>module:xduce.take</code> transducers.) It is of little use beyond
transducer authoring.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/value</code> protocol. This is used
internally to mark properties that contain the value of a completed
transformation. It is of little use beyond transducer authoring.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>The mapping of protocol names to their respective property key names. This
mapping makes it easier to deal with these protocols as they can be looked up
by string name rather than by more difficult-to-work-with symbols.</p>
</div>



    <h5>Type:</h5>
    <ul>
        <li>
            
<span class="param-type">object</span>


        </li>
    </ul>






            
                
<h4 class="name" id=".ReducerObject">ReducerObject</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line353">line 353</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>Symbol.for("transducer/init")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.InitFunction">module:xdcore.InitFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
function that can create a new, empty copy of the reducible type.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("transducer/step")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
function that can accept a value of the reducible type and a new element
to be added to it and return the reducible with the new element
incorporated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("transducer/result")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ResultFunction">module:xdcore.ResultFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
function that accepts a value of the reducible type and returns the same
value with any final modifications that might be necessary for it.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>An object that provides the information necessary to build and populate a new
object of a reducible type. This information is used by the transduction
engine to create a result from a reduction without having to have its own
type-specific code; the creation, population, and finalization of the result
are delegated instead to this reducer object.</p>
<p>Note that a &quot;transducer object&quot; has exactly the same structure. The only
difference is that the step function in a transducer object modifies the
elements before it reduces them, while a reducer object will not. As a
corollary, every reducer object is also a transducer object, but the converse
is not true.</p>
</div>








            
                

    

    <h4 class="name" id=".ResultFunction"><span class="type-signature"></span>ResultFunction<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line336">line 336</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a fully reduced collection and returns that
collection with any last-minute modifications that might need to be done to
it.</p>
<p>In most cases this function will simply return its argument, unmodified, but
it does afford the transducer an opportunity to make any final modifications
that might be necessary before the result is returned from the transduction
process.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The fully reduced collection.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The reduced collection with any implementation-dependent changes
that might be deemed necessary.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                

    

    <h4 class="name" id=".StepFunction"><span class="type-signature"></span>StepFunction<span class="signature">(acc, value)</span><span class="type-signature"></span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line316">line 316</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a collection and a new element of that collection and
returns the collection with the new element added to it. This is used to
build up a new collection (starting with whatever
<a href="module-xdcore.html#.InitFunction">the init function</a> returns) piece by piece
from its elements.</p>
<p>This is in every way a reducer function. The name 'step' comes from the fact
that these reduction functions reduce one element at a time, step by step.</p>
<p>It is up to the implementation whether the returned collection is a modified
form of the original collection or whether it is a new collection altogether.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>acc</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A collection, perhaps with some members already added to it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A new element to be added to that collection.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The original collection with the new value added to it.</p>
</div>



    



            
                

    

    <h4 class="name" id=".TransducerFunction"><span class="type-signature"></span>TransducerFunction<span class="signature">(reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line379">line 379</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a reducer object, which it then chains a transducer
object to. This is the primary way of creating composed transducer chains.</p>
<p>A transducer function basically encapsulates a transducer object and the
ability to chain it to whatever reducer object is passed to it.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>The reducer object (which may
also be a transducer object) that is the next reducer in the chain.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A transducer object consisting of some
new transducer object chained to the supplied reducer object.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



            
    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Tue Mar 31 2020 11:43:51 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>