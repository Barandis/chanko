<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>xdcore - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-csp.html">csp</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-csp.html#.chan">chan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.channel">channel</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.close">close</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.config">config</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.dropping">dropping</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.fixed">fixed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.go">go</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isBuffered">isBuffered</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isClosed">isClosed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.isTimed">isTimed</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.join">join</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recv">recv</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recvAsync">recvAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.recvOrThrow">recvOrThrow</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.select">select</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.selectAsync">selectAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.send">send</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sendAsync">sendAsync</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sleep">sleep</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.sliding">sliding</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.timedChan">timedChan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.transChan">transChan</a></li><li data-type='method' style='display: none;'><a href="module-csp.html#.value">value</a></li></ul></li><li><a href="module-csp-ops.html">csp-ops</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.debounce">debounce</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.map">map</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.merge">merge</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.partition">partition</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.pipe">pipe</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.split">split</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.tap">tap</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.throttle">throttle</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.toArray">toArray</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.toChannel">toChannel</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.untap">untap</a></li><li data-type='method' style='display: none;'><a href="module-csp-ops.html#.untapAll">untapAll</a></li></ul></li><li><a href="module-xdcore.html">xdcore</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-xdcore.html#.complete">complete</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.ensureCompleted">ensureCompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.ensureUncompleted">ensureUncompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isArray">isArray</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isCompleted">isCompleted</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isFunction">isFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isGeneratorFunction">isGeneratorFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isImplemented">isImplemented</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isIterable">isIterable</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isNumber">isNumber</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isObject">isObject</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.isString">isString</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.iterator">iterator</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.reduce">reduce</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toFunction">toFunction</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toReducer">toReducer</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.toTransducer">toTransducer</a></li><li data-type='method' style='display: none;'><a href="module-xdcore.html#.uncomplete">uncomplete</a></li></ul></li><li><a href="module-xduce.html">xduce</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-xduce.html#.asArray">asArray</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asIterator">asIterator</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asObject">asObject</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.asString">asString</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.complement">complement</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.compose">compose</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.identity">identity</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.into">into</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.key">key</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.kv">kv</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.repeat">repeat</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.sequence">sequence</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.transduce">transduce</a></li><li data-type='method' style='display: none;'><a href="module-xduce.html#.value">value</a></li></ul></li></ul><h3>Externals</h3><ul><li><a href="external-Iterable.html">Iterable</a></li><li><a href="external-Iterator.html">Iterator</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">xdcore</h1>
    

    




<section>

<header>
    
        
            
        
    
</header>

<article>
    
        <div class="container-overview">
        
            
                <div class="description usertext"><p>The core engine for transducers. This consists primarily of reduction support
for chains of transducers but also supplies protocol definitions and utility
functions for writing new transducers.</p>
<p>The general idea is that if you need to use a transducer, you can avoid
importing this library and work with the <a href="module-xduce.html">xduce</a> module
instead (which internally depends on this module). If you want to write a new
transducer or control low-level access to the reduction engine, then you need
to use this library. (There is a small number of functions that are useful
for both, and <a href="module-xduce.html">xduce</a> re-exports them from here so they
can be used from either module.)</p>
<p>This module provides four basic services:</p>
<ol>
<li>Reduction of transducer chains</li>
<li>Protocol definition</li>
<li>Iteration support</li>
<li>Authoring utilities</li>
</ol>
<p>What follows is a short diuscussion of each.</p>
<h2>Reduction</h2>
<p>All transforming functions, whether methods of <code>Array</code> or third party tools
such as Lodash, perform reduction in order to build up a new collection out
of the elements that they've transformed/filtered, etc.</p>
<p>Transducers are no different in that regard, but the manner in which they do
their reduction is what sets them apart.</p>
<p>Using <code>Array.prototype.map</code> as an example, the user of the function provides
a transformation function. The <code>map</code> function iterates over the input array,
passes the elements through the provided transformation function, and then
reduces the results into a new array. If <code>map</code> is chained to another
function, like <code>Array.prototype.filter</code>, the process needs to be repeated:
iterate again, filter via a user-provided function, and reduce again.</p>
<p>Transducers are different. When using a transducer, rather than a
manipulation function being provided as in <code>map</code> or <code>filter</code>, a <em>reducer
object</em> is used. (It's an object rather than a function because it has
multiple functions, each implemented as properties of the reducer object.)
This means that the user provides instructions for both transformation <em>and</em>
reduction, rather than the collection function itself being responsible for
doing the reduction on its own.</p>
<p>This has two very beneficial effects. First, if a user wants to filter and
then map the elements of a collection, the transducer does not have to reduce
the filtered elements into a collection just to have the map part tear them
apart again and re-reduce them later. The filter part of the transducer can
pass its elements one at a time to the map part, and reduction can happen
only at the end after the elements have been both filtered <em>and</em> mapped.</p>
<p>Secondly, since the user is providing the reduction instructions along with
the transformation instructions, the type of collection that gets reduced
into does not have to be the same type as the input collection. You could
process characters in a string and have it output as an array. Or process the
values in an iterator and get a plain object as output.</p>
<p>Practically speaking, most of the reducer object creation is abstracted away,
so using transducers is no more difficult than just using
<code>Array.prototype.map</code>. The <code><a href="module-xdcore.html#.reduce">reduce</a></code> function
provided by this library is low level, though, and does not do any of that
abstracting on its own. The functions from the <a href="module-xduce.html">xduce</a>
module, namely <code><a href="module-xduce.html#.transduce">transduce</a></code>,
<code><a href="module-xduce.html#.into">into</a></code>, and
<code><a href="module-xduce.html#.sequence">sequence</a></code>, take care of that abstraction so
<code><a href="module-xdcore.html#.reduce">reduce</a></code> can just handle actual reduction.</p>
<h2>Protocols</h2>
<p>In ES2015, the idea of protocols was added to JavaScript. This was done at
the beginning to provide language-level support for the new <code>for...of</code> loop.
As long as a value supported the iterable protocol by having a property named
<code>Symbol.iterator</code> that returns an iterator for that value when it's called,
then it automatically qualified to be used in <code>for...of</code>.</p>
<p>This module uses that iterable module in the same way to understand how to
break collections apart, but it also uses protocols to let collections inform
the engine how to reduce a collection of that type back together again. Since
there are no standard protocols for reduction the way there are for
iteration, this module provides custom protocols of its own. These are also
symbols used as names for properties, but they are stored in an object called
<code><a href="module-xdcore.html#.protocols">protocols</a></code> to be looked up by string key:</p>
<ul>
<li><code>protocols.init</code></li>
<li><code>protocols.step</code></li>
<li><code>protocols.final</code></li>
<li><code>protocols.completed</code></li>
<li><code>protocols.value</code></li>
</ul>
<p>The last two (<code>completed</code> and <code>value</code>) are used internally for keeping track
of the reduction status of a value and shouldn't need to be used externally.
The first three, however, are how the engine knows how to reduce to a certain
collection type.</p>
<p><code>init</code> is a function that returns a new, empty version of that collection to
be built upon. <code>step</code> is a function that gets passed a collection of that
type plus a new value to be added to it, and returns the collection with that
value added to it (i.e., it's a standard reduction function). <code>final</code> is a
function that gets passed the fully reduced new collection and returns what
the final output should be, giving the engine one last chance to modify the
final value (this <em>normally</em> just returns its argument unmodified). If these
three properties are added to an object, then this module will recognize that
object as reducible and be able to create and fill one.</p>
<p>As an example, let's add support for transduction to the <code>List</code> collection
from <a href="https://immutable-js.github.io/immutable-js/">immutable.js</a>.</p>
<pre class="prettyprint source"><code>import { protocols as p } from &quot;@chanko/xdcore&quot;;
import { List } from &quot;immutable&quot;;

List.prototype[p.init] = () => List().asMutable();
List.prototype[p.step] = (acc, value) => acc.push(value);
List.prototype[p.final] = value => value.asImmutable();
</code></pre>
<p>The <code>init</code> function here returns a new, empty list. The <code>step</code> function
describes how to add a value to that list (through the <code>push</code> method). The
<code>final</code> function runs at the very end to determine the end value. In the case
of this immutable list, the <code>init</code> function actually returns a mutable list
that we can add to with <code>step</code>, and then <code>final</code> turns that into an immutable
list to be returned. This is a textbook use of <code>final</code>; most of the time,
<code>final</code> will simply return the value that's passed to it, unchanged.</p>
<p>With these lines of code in place, adding the protocol functions to <code>List</code>'s
prototype, reduction will just work.</p>
<p>It is not necessary to provide these functions for native arrays, strings,
plain objects, or iterators, as support for them is built in.</p>
<h2>Iterators</h2>
<p>As mentioned above, there is a built-in protocol for iteration in JavaScript
since ES2015, and this module does recognize and use that protocol. (Because
this is a built-in protocol, even many third-party libraries take advantage
of it; we did not have to add the iterable protocol to the immutable <code>List</code>
above because immutable.js already adds it.)</p>
<p>Iteratable protocol support works out of the box for any type that implements
it. However, there is also support built into this module for two types that
do not support the protocol: plain objects and functions.</p>
<p>The values that come out of the iterator for plain objects are themselves
objects, but they're objects of only one property each, one for each property
in the original object. For example:</p>
<pre class="prettyprint source"><code>import { iterator } from &quot;@chanko/xdcore&quot;;

const obj = { c: 1, a: 2, b: 3 };
const iter = iterator(obj);
console.log(iter.next().value);   // -> { c: 1 }
console.log(iter.next().value);   // -> { a: 2 }
console.log(iter.next().value);   // -> { b: 3 }
console.log(iter.next().done);    // -> true
</code></pre>
<p>The ordering is the same as ordering from <code>Object.keys()</code> and the like:</p>
<ol>
<li>String keys that are integer indices in ascending numerical order</li>
<li>All other string keys in the order in which they were added to the object</li>
<li>All symbol keys in the order in which they were added to the object</li>
</ol>
<p>Iteration support for functions happens by invoking the function for each
iteration and using the return value for the value of the iterator at that
point. Two values are fed into the function: the index of the iteration
(starting at 0 for the first iteration and increasing by one for each
subsequent iteration) and the function's return value from the previous
iteration (starting as <code>undefined</code> for the first iteration). The function is
free to use or ignore these values as it likes; all that is important is that
it returns a value.</p>
<pre class="prettyprint source"><code>import { iterator } from &quot;@chanko/xdcore&quot;;

const fn = (index, last = 1) => last * (index + 1);
const iter = iterator(fn);
console.log(iter.next().value);   // -> 1
console.log(iter.next().value);   // -> 2
console.log(iter.next().value);   // -> 6
console.log(iter.next().value);   // -> 24
console.log(iter.next().value);   // -> 120
</code></pre>
<p>This effectively calculates the factorial of <code>(index + 1)</code>. As in this
example, iterators created from functions can be infinite; if the function
returns <code>undefined</code> it'll terminate the iterator immediately.</p>
<h2>Authoring</h2>
<p>The tools from this module are used by the <a href="module-xduce.html">xduce</a> module
to build its transducers, and all of those same tools are available for
custom transducers as well.</p>
<p>In brief, a transducer works by having <em>transducer objects</em> which are formed
into a chain, one for each transformation. At the end of the chain is a
<em>reducer object</em> which describes how to create a new collection from the
elements that the transducer objects modified. Elements are pulled one at a
time through that chain, being modified, filtered out, etc. every step of the
way until the reducer at the end adds it into the target collection.</p>
<p>Visually, a transducer that maps element values, filters them, and outputs an
array containing those elements would look like this:</p>
<pre class="prettyprint source"><code>+---------------+    +---------------+    +---------------+
|  map xducer   | -> | filter xducer | -> | array reducer |
+---------------+    +---------------+    +---------------+
</code></pre>
<p>There is always one reducer object at the end and an arbitrary number of
transducer objects before it.</p>
<p>Transducer and reducer objects are structurally identical. They both are
required to have the three reduction protocol methods (<code>init</code>, <code>step</code>, and
<code>final</code>). Their difference is in their purpose.</p>
<p>A reducer object is responsible for providing an initial collection (<code>init</code>),
adding elements one by one to that collection (<code>step</code>), and finalizing the
result (<code>final</code>). It is self-contained and its protocol methods don't
typically need to call any other reducer objects. Since it is the last object
in the chain, it's possible for a chain to consist of <em>only</em> a reducer (this
is useful for turning one kind of collection into another without changing
any of the elements).</p>
<p>A transducer object is responsible for two things: manipulating data, and
then passing that data along to the next object in the chain. For that
reason, the <code>init</code> and <code>final</code> methods typically simply call the same method
on the next object and return its value (i.e., they do nothing themselves).
The <code>step</code> method is where the work happens, and when that work is done, it's
sent to the next object by calling <em>its</em> <code>step</code> method. A transducer object
cannot make a chain by itself; it always requires a reducer object to
actually put the manipulated data back together.</p>
<p>The reason that a transducer object needs these protocol methods even if they
only call the next one is because a transducer object should not need to know
whether the next object in the chain is a transducer object or a reducer
object. All it needs to know is that there will be an object with the three
reduction protocol methods that it can call. (There are also edge cases where
a transducer object may do more with an <code>init</code> or <code>final</code> method, but those
are fairly rare.)</p>
<p>Here is an example of transducer definitions, using the same two transducer
objects as in the above diagram. It defines two <em>transducer functions</em>, which
are functions that take a transducer or reducer object (which is the next
object in the chain) and return its own transducer object already chained to
that next object.</p>
<pre class="prettyprint source"><code>import { protocols as p } from &quot;@chanko/xdcore&quot;;

function mapTransducer(fn, next) {
  return {
    [p.init]: () => next[p.init](),
    [p.step]: (acc, value) => next[p.step](acc, fn(value)),
    [p.final]: value => next[p.final](value),
  };
}

function filterTransducer(fn, next) {
  return {
    [p.init]: () => next[p.init](),
    [p.step]: (acc, value) => fn(value) ? next[p.step](acc, value) : acc,
    [p.final]: value => next[p.final](value),
  };
}
</code></pre>
<p>As expected, the <code>init</code> and <code>final</code> methods in both transducer objects simply
call the same functions in the next object, while the <code>step</code> function does
the actual work, either passing each value through the mapping function in
<code>mapTransducer</code> or deciding whether to add it to the collection at all in
<code>filterTransducer</code>.</p>
<p>Since it <em>is</em> so common to create transducer objects whose <code>init</code> and <code>final</code>
methods simply chain to the next object, there is a helper function to make
transducer object creation easier. The same two transducer functions from
above can be written like this.</p>
<pre class="prettyprint source"><code>import { protocols as p, toTransducer } from &quot;@chanko/xdcore&quot;;

function mapTransducer(fn, next) {
  const step = (acc, value) => next[p.step](acc, fn(value));
  return toTransducer(step, next);
}

function filterTransducer(fn, next) {
  const step = (acc, value) => fn(value) ? next[p.step](acc, value) : acc;
  return toTransducer(step, next);
}
</code></pre>
<p><code><a href="module-xdcore.html#.toTransducer">toTransducer</a></code> takes a step function and
the next object and takes care of the <code>init</code> and <code>final</code> methods for you.</p>
<p>If you plan to write your transducers to work with high-level
<a href="module-xduce.html">xduce</a> functions like
<code><a href="module-xduce.html#.sequence">sequence</a></code> or
<code><a href="module-xduce.html#.transduce">transduce</a></code>, then this is enough. You don't
need to go any further. However, this is not enough for the
<code><a href="module-xdcore.html#.reduce">reduce</a></code> function, which expects a <em>reducer</em>
object, not a transducer object. (<code><a href="module-xduce.html#.transduce">transduce</a></code>
also expects a reducer object, but that's <em>in addition to</em> a transducer
object and not in place of one.) <code><a href="module-xdcore.html#.reduce">reduce</a></code>
doesn't care if that reducer object has other transducer objects chained to
it; it only cares that the whole object acts like a reducer, which it will
use to build a new collection.</p>
<p>There is a similar function for reducer objects, called
<code><a href="module-xdcore.html#.toReducer">toReducer</a></code>. It takes a <em>reducible object</em>
and returns a reducer object for it. A reducible object is any object that
has the three reducer protocol functions on it to describe how a new
collection of its type is made; in the immutable list example above, after
you add the protocol methods to it, <code>List</code> is a reducible object. Arrays,
strings, functions, and plain objects are also reducible objects by virtue of
specific support built into <code><a href="module-xdcore.html#.toReducer">toReducer</a></code>.</p>
<p>With these two simple functions, we can pretty easily use
<code><a href="module-xdcore.html#.reduce">reduce</a></code> directly to perform the transduction
diagrammed above.</p>
<pre class="prettyprint source"><code>import { toReducer, reduce } from &quot;@chanko/xdcore&quot;;

const isEven = x => x % 2 === 0;
const addOne = x => x + 1;

let reducer = toReducer([]);
reducer = filterTransducer(isEven, reducer);
reducer = mapTransducer(addOne, reducer);

const r = reduce([1, 2, 3, 4, 5], reducer, []);
console.log(r);   // -> [2, 4, 6]
</code></pre>
<p>There are some important points to notice about this example.</p>
<ol>
<li>The transducer chain is built backwards, starting from the reducer and
adding the transducers in reverse order. This makes sense, as each
transducer function requires a reference to the following
transducer/reducer object when it's called.</li>
<li>This creates an array, but since
<code><a href="module-xdcore.html#.toReducer">toReducer</a></code> can create a reducer object
from any reducible object, we could have passed <code>List</code> to it (after adding
the three protocol properties as in the earlier immutable list example)
and <code><a href="module-xdcore.html#.reduce">reduce</a></code> would return an immutable list
instead. (Sort of...<code><a href="module-xdcore.html#.reduce">reduce</a></code> actually only
deals with <code>step</code> and <code>final</code> protocol methods because internally, it
sometimes works with reducer objects that don't have an <code>init</code> protocol
method, like ones created from functions. This is why
<code><a href="module-xdcore.html#.reduce">reduce</a></code> takes a third parameter, called
<code>init</code>. So for this to work properly with an immutable list, you would
also have to pass <code>List().asMutable()</code> as the third parameter, in place of
<code>[]</code> in the example code. This is not something you have to worry about
with higher-level functions in the <a href="module-xduce.html">xduce</a> module.)</li>
<li>This is all more easily done using the <a href="module-xduce.html">xduce</a> module,
which handles much of this work for you. This example just shows how you
can build your own transducer objects, chain them together, and use
<code><a href="module-xdcore.html#.reduce">reduce</a></code> to process them.</li>
</ol>
<p>Here is what it would look like with the <a href="module-xduce.html">xduce</a> module.</p>
<pre class="prettyprint source"><code>import { map, filter, sequence, compose } from &quot;@chanko/xduce&quot;;

const isEven = x => x % 2 === 0;
const addOne = x => x + 1;

const r = sequence([1, 2, 3, 4, 5], compose(map(addOne), filter(isEven)));
console.log(r);   // -> [2, 4, 6]
</code></pre>
<p>More details are available in the documentation for the
<a href="module-xduce.html">xduce</a> module, but basically
<code><a href="module-xduce.html#.compose">compose</a></code> chains transducer objects together,
while <code><a href="module-xduce.html#.sequence">sequence</a></code> figures out what initial
collection and what reducer object to use (from the input collection), chains
the transducer objects to the reducer object, and passes all of the relevant
information to <code><a href="module-xdcore.html#.reduce">reduce</a></code>.</p>
<p><code><a href="module-xdcore.html#.reduce">reduce</a></code> works in a simple way, but there is one
bit of special functionality that's relevant to writing transducers. If it
processes an element and the value returned by the reducer/transducer chain
is a <em>completed value</em>, it will cease the reduction right there even if there
are more elements in the input collection. A completed value is a value that
is wrapped in an object using the other two reducer protocol properties,
<code>completed</code> and <code>value</code>:</p>
<pre class="prettyprint source"><code>import { protocols as p } from &quot;@chanko/xdcore&quot;;

// A regular value
const value = 1729;

// A completed version of that same value
const completed = {
  [p.completed]: true,
  [p.value]: 1729,
};
</code></pre>
<p>The reason for the long-windedness of using a wrapper is so that a completed
value can be completed again, making it double-wrapped. This is occasionally
useful in writing more complex transducers, and it is simplest to achieve
with a wrapper.</p>
<p>A good example of the use of a completed value is the
<code>take</code> transducer, which returns a certain number
of elements and then returns no more. Here's how it would look using
<a href="module-xduce.html">xduce</a>:</p>
<pre class="prettyprint source"><code>import { take } from &quot;@chanko/xduce&quot;;
const r = take([1, 2, 3, 4, 5], 2);
console.log(r);   // -> [1, 2]
</code></pre>
<p>No matter how many elements are in the input collection,
<code>take</code> will only process a certain number (in this
case, 2). The input collection could even be a generator that never
terminates, and it would still work fine. <code>take</code>
does this by, at some point, returning a completed, which in turn causes
<code><a href="module-xdcore.html#.reduce">reduce</a></code> to stop processing.</p>
<pre class="prettyprint source"><code>import { protocols as p, toTransducer } from &quot;@chanko/xdcore&quot;;

function takeTransducer(n, next) {
  let i = 0;
  const step = (acc, value) => {
    let result = next[p.step](acc, value);
    if (i === n - 1) {
      result = {
        [p.completed]: true,
        [p.value]: result,
      };
    }
    i++;
    return result;
  };
  return toTransducer(step, next);
}
</code></pre>
<p>This is a bit more complex, but the gist of it is that the transducer object
simply passes the value on down the chain. However, if the element being
processed is the last one before it reaches the target number of elements,
the value returned from the chain is wrapped as a completed object.
<code><a href="module-xdcore.html#.reduce">reduce</a></code> will see this value and stop the
process as soon as it does.</p>
<p>As you might expect, there are helper functions for writing transducers like
this:</p>
<ul>
<li><code><a href="module-xdcore.html#.complete">complete</a></code></li>
<li><code><a href="module-xdcore.html#.uncomplete">uncomplete</a></code></li>
<li><code><a href="module-xdcore.html#.ensureCompleted">ensureCompleted</a></code></li>
<li><code><a href="module-xdcore.html#.ensureUncompleted">ensureUncompleted</a></code></li>
<li><code><a href="module-xdcore.html#.isCompleted">isCompleted</a></code></li>
</ul>
<p>The first two either wrap or unwrap a value in the completed wrapper. The
third and fourth do the same thing, but they only do it if it's actually
necessary to do so (<code><a href="module-xdcore.html#.complete">complete</a></code> will
double-wrap a value if passed an already-completed value;
<code><a href="module-xdcore.html#.ensureCompleted">ensureCompleted</a></code> will not do this
double wrapping). The final function simply returns whether or not the value
passed to it is a completed object.</p>
<p>These functions mean that you should never have to work directly with either
the <code>completed</code> or <code>value</code> reducer protocol properties.</p>
<p>With those in mind, the actual step function for the take transducer is a
little simpler.</p>
<pre class="prettyprint source"><code>const step = (acc, value) => {
  let result = next[p.step](acc, value);
  if (i === n - 1) {
    result = complete(result);
  }
  i++;
  return result;
};
</code></pre>
<p>After all that, one final bit of provided functionality: there are a series
of helper functions to determine the type of a value.</p>
<ul>
<li><code><a href="module-xdcore.html#.isArray">isArray</a></code></li>
<li><code><a href="module-xdcore.html#.isFunction">isFunction</a></code></li>
<li><code><a href="module-xdcore.html#.isGeneratorFunction">isGeneratorFunction</a></code></li>
<li><code><a href="module-xdcore.html#.isNumber">isNumber</a></code></li>
<li><code><a href="module-xdcore.html#.isObject">isObject</a></code></li>
<li><code><a href="module-xdcore.html#.isString">isString</a></code></li>
</ul>
<p>These all work as you might expect, with a few caveats.</p>
<ol>
<li><code><a href="module-xdcore.html#.isFunction">isFunction</a></code> will return <code>false</code> if
passed a generator function. Use
<code><a href="module-xdcore.html#.isGeneratorFunction">isGeneratorFunction</a></code> to check
for those.</li>
<li><code><a href="module-xdcore.html#.isNumber">isNumber</a></code> is only for concrete numbers
that are not strings. It will return <code>false</code> for <code>Infinity</code>, <code>NaN</code>, and
things like <code>&quot;1729&quot;</code>.</li>
<li><code><a href="module-xdcore.html#.isObject">isObject</a></code> returns <code>true</code> only for plain
objects. It will return <code>false</code> for any other sort of object, including
things like arrays, objects with constructors (from classes or from
constructor functions), and <code>null</code> (which famously returns <code>&quot;object&quot;</code> when
<code>typeof</code> is used on it).</li>
<li><code><a href="module-xdcore.html#.isArray">isArray</a></code> is just the regular
<code>Array.isArray</code>, packaged here for consistency.</li>
</ol></div>
            

            
                




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line8">line 8</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>
































            
        
        </div>
    

    

    

    
    
    

     

    

    
        <h3 class="subsection-title">Members</h3>

        
            
<h4 class="name" id=".protocols"><span class="type-signature">(static, constant) </span>protocols<span class="type-signature"> :<a href="module-xdcore.html#.ProtocolMap">module:xdcore.ProtocolMap</a></span></h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line51">line 51</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>The mapping of protocol names to their respective property key names.</p>
</div>



    <h5>Type:</h5>
    <ul>
        <li>
            
<span class="param-type"><a href="module-xdcore.html#.ProtocolMap">module:xdcore.ProtocolMap</a></span>


        </li>
    </ul>






        
    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".complete"><span class="type-signature">(static) </span>complete<span class="signature">(value)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.CompletedValue">module:xdcore.CompletedValue</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line327">line 327</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Marks a value as complete.</p>
<p>This is done by wrapping the value. This means three things: first, a
complete object may be marked as complete again; second, a complete value
isn't usable without being uncompleted first; and third any type of value
(including <code>undefined</code>) may be marked as complete.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be completed.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A completed version of the provided
value. This effect is achieved by wrapping the value in a marker object.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.CompletedValue">module:xdcore.CompletedValue</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".ensureCompleted"><span class="type-signature">(static) </span>ensureCompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line375">line 375</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Makes sure that a value is marked as complete; if it is not, it will be
marked as complete.</p>
<p>This differs from <a href="module-xdcore.html#.complete">complete</a> in that if the
value is already complete, this function won't complete it again. Therefore
thus function can't be used to make a value complete multiple times.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be completed.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>If the value is already complete, then the value is simply
returned. Otherwise, a completed version of the value is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".ensureUncompleted"><span class="type-signature">(static) </span>ensureUncompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line391">line 391</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Removes the complete status from a value, as long as it actually is complete.</p>
<p>This does a check to make sure the value passed in actually is complete. If
it isn't, the value itself is returned. It's meant to be used when the
completed status is uncertain.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The complete value to be uncompleted.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>If the value is already uncompleted, the value is simply
returned. Otherwise an uncompleted version of the value is returned.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isArray"><span class="type-signature">(static) </span>isArray<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line118">line 118</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is an array.</p>
<p>This function merely delegates to <code>Array.isArray</code>. It is provided for
consistency in calling style only.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is an array.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is an array or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isCompleted"><span class="type-signature">(static) </span>isCompleted<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line358">line 358</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is marked as complete.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to test for its complete status.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the value is completed, or <code>false</code> if it
is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isFunction"><span class="type-signature">(static) </span>isFunction<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line33">line 33</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a function.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a function or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isGeneratorFunction"><span class="type-signature">(static) </span>isGeneratorFunction<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line45">line 45</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a generator function.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a generator function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a generator function or
<code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isImplemented"><span class="type-signature">(static) </span>isImplemented<span class="signature">(obj, protocol)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line92">line 92</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a particular protocol is implemented by a value. The
possible values for <code>protocol</code> are the following, representing the two
built-in iterator protocols and the five custom transducer protocols:</p>
<ul>
<li><code>iterator</code></li>
<li><code>asyncItrerator</code></li>
<li><code>init</code></li>
<li><code>step</code></li>
<li><code>final</code></li>
<li><code>completed</code></li>
<li><code>value</code></li>
</ul>
<p>Any of these will result in <code>true</code> if the object in question has a property
that matches the one necessary to implement the protocol. Further, any of
the properties other than <code>completed</code> and <code>step</code> must be functions.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>obj</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>


            
            </td>

            

            

            <td class="description last"><p>The object to check for protocol implementation.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>protocol</code></td>
            

            <td class="type">
            
                
<span class="param-type">string</span>


            
            </td>

            

            

            <td class="description last"><p>The name of the protocol to check for.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the object supports the named protocol or
<code>false</code> if it does not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isIterable"><span class="type-signature">(static) </span>isIterable<span class="signature">(value)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_iteration.js.html">xdcore/src/modules/iteration.js</a>, <a href="xdcore_src_modules_iteration.js.html#line179">line 179</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether the passed object is iterable, in terms of what 'iterable'
means to this library. In other words, values implementing the <code>iterable</code>
protocol and plain objects return <code>true</code>, while everything else returns
<code>false</code>. This does not return <code>true</code> for functions even though
<a href="module-xdcore.html#.iterator">iterator</a> can produce an iterator for them,
because not all functions work well with
<a href="module-xdcore.html#.iterator">iterator</a>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to test for iterability.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the value is iterable
(<code><a href="module-xdcore.html#.iterator">iterator</a></code> will return an iterator for
it) or <code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isNumber"><span class="type-signature">(static) </span>isNumber<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line100">line 100</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a concrete number.</p>
<p>This function will return <code>true</code> for any number literal or instance of
<code>Number</code> except for <code>Infinity</code> or <code>NaN</code>. It will return <code>false</code> for strings
that happen to also be numbers; the value must be an actual <code>Number</code> instance
or number literal to return <code>true</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a number.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a finite number (not
including string representations of numbers) or <code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isObject"><span class="type-signature">(static) </span>isObject<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line64">line 64</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a plain object.</p>
<p>This function returns <code>false</code> if the value is any other sort of built-in
object (such as an array or a string). It also returns <code>false</code> for any object
that is created by a constructor that is not <code>Object</code>'s constructor, meaning
that &quot;instances&quot; of custom &quot;classes&quot; will return <code>false</code>. Therefore it's only
going to return <code>true</code> for literal objects or those created with
<code>Object.create()</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a plain object.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a plain object or
<code>false</code> if it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".isString"><span class="type-signature">(static) </span>isString<span class="signature">(x)</span><span class="type-signature"> &rarr; {boolean}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_utils.js.html">xdcore/src/modules/utils.js</a>, <a href="xdcore_src_modules_utils.js.html#line114">line 114</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Determines whether a value is a string.</p>
<p>Literal strings will return <code>true</code>, as will instances of the <code>String</code> object.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value being tested to see if it is a string.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>Either <code>true</code> if the test value is a string or <code>false</code> if
it is not.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">boolean</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".iterator"><span class="type-signature">(static) </span>iterator<span class="signature">(value)</span><span class="type-signature"> &rarr; {<a href="external-Iterator.html">external:Iterator</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_iteration.js.html">xdcore/src/modules/iteration.js</a>, <a href="xdcore_src_modules_iteration.js.html#line150">line 150</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates an iterator over the provided value. The form of the iteration
depends on what kind of value is being iterated over.</p>
<p>If the value is a collection implementing the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol">iterable protocol</a> (arrays,
strings, generators, or a custom object supporting the protocol) then the
produced iterator will be as expected: an object that implements the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol">iterator protocol</a> by providing a <code>next</code> function that returns each
collection value in turn.</p>
<pre class="prettyprint source"><code>const iter = iterator([1, 2, 3]);
console.log(iter.next().value);   // -> 1
console.log(iter.next().value);   // -> 2
console.log(iter.next().value);   // -> 3
console.log(iter.next().done);    // -> true
</code></pre>
<p>Special support is provided for two types that are not normally iterable:
objects and functions.</p>
<p>Objects result in an iterator that produces a single-property object for
every key/value pair in the supplied object. The <a href="https://2ality.com/2015/10/property-traversal-order-es6.html">order of iteration</a> is
the same as it is for objects post-ES2015:</p>
<ol>
<li>String keys that are integer indices in ascending numerical order</li>
<li>All other string keys in the order in which they were added to the object</li>
<li>All symbol keys in the order in which they were added to the object</li>
</ol>
<pre class="prettyprint source"><code>const obj = {
  [Symbol(&quot;first&quot;)]: true,
  02: true,
  10: true,
  01: true,
  2: true,
  [Symbol(&quot;second&quot;)]: true
};
const iter = iterator(obj);
console.log(iter.next().value);   // -> { '2': true }
console.log(iter.next().value);   // -> { '10': true }
console.log(iter.next().value);   // -> { '02': true }
console.log(iter.next().value);   // -> { '01': true }
console.log(iter.next().value);   // -> { [Symbol('first')]: true }
console.log(iter.next().value);   // -> { [Symbol('second')]: true }
console.log(iter.next().done);    // -> true
</code></pre>
<p>Functions are run each time the iterator's <code>next</code> method is called, and the
return value of the function is supplied as the iterator's value at that
point.</p>
<p>This function is provided two arguments: the zero-based index of that
iteration, and the value produced by the last invocation of the iterator. The
last value is <code>undefined</code> on the first pass, but a default parameter on the
function can define the first pass value to be whatever is needed.</p>
<pre class="prettyprint source"><code>const fn = (index, last = 1) => last * (index + 1);
const iter = iterator(fn);
console.log(iter.next().value);   // -> 1
console.log(iter.next().value);   // -> 2
console.log(iter.next().value);   // -> 6
console.log(iter.next().value);   // -> 24
console.log(iter.next().value);   // -> 120
</code></pre>
<p>Iterators created from functions are, by default, infinite since there is no
condition for them to not be able to be applied one more time. To create a
finite iterator from a function, have it return <code>undefined</code> at some point.
When a return value of <code>undefined</code> is encountered, <code>iterator</code> will terminate
the iterator, setting its next <code>done</code> property to <code>true</code>.</p>
<p>If the input value is neither iterable, object, or function, then the result
will be <code>null</code>.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">object</span>
|

<span class="param-type"><a href="module-xdcore.html#.IterableFunction">module:xdcore.IterableFunction</a></span>
|

<span class="param-type"><a href="external-Iterable.html">external:Iterable</a></span>


            
            </td>

            

            

            <td class="description last"><p>The value to create an iterator over.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An iterator over <code>value</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="external-Iterator.html">external:Iterator</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".reduce"><span class="type-signature">(static) </span>reduce<span class="signature">(collection, reducer, init)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line434">line 434</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Reduces the elements of the input collection through a reducer into an output
collection.</p>
<p>This is the lowest-level of the transduction functions. In fact, this one is
so low-level that it doesn't have a lot of use in normal operation. It's more
useful for writing your own transformation functions.</p>
<p><code>reduce</code> doesn't assume that there's even a transformation. It requires an
initial collection and a reducer object that is matched to that initial
collection. The reducer object must implement the <code>step</code> and <code>result</code>
protocols, which instruct <code>reduce</code> on how to build up the collection. The
reducer may implement a transformation as well, but all that's important here
is that it can do the reduction.</p>
<p>The input collection need only implement <code>iterable</code>. It is not necessary for
the input and output collections to be of the same type; as long as the input
implements <code>iterable</code> and the reducer implements <code>step</code> and <code>result</code>
appropriate to the type of the <code>init</code> collection, then any translation
between collection types can occur.</p>
<p>The normal course of operation will be to call
<a href="module-xduce.html#.transduce">transduce</a> instead, as that function makes it
easy to combine transformations with reductions and can optionally figure out
the initial collection itself.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>collection</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The input collection. The only requirement of this
collection is that it implement the <code>iterable</code> protocol. Special support
is provided by the library for objects, so they can be used as well.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>An object that implements the
<code>step</code> and <code>result</code> protocols. This object must know how to produce an
output collection through those protocol functions.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>init</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>a collection of the same type as the output collection. It
need not be empty; if it is not, the existing elements are retained as
the input collection is reduced into it.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new collection, consisting of the <code>init</code> collection with all of
the elements of the <code>collection</code> collection reduced into it.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toFunction"><span class="type-signature">(static) </span>toFunction<span class="signature">(transducer, reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line296">line 296</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a reducer function from a transducer function and a reducer.</p>
<p>This produces a function that's suitable for being passed into other
libraries' reduce functions, such as JavaScript's <code>Array.prototype.reduce</code> or
Lodash's <code>_.reduce</code>. It requires both a transducer <em>and</em> a reducer because
reduction functions for those libraries must know how to reduce as well as
how to transform. The reducer can be a standard reducer object like the ones
sent to <code><a href="module-xdcore.html#.reduce">reduce</a></code>, or it can be a plain function
that takes two parameters and returns the result of reducing the second
parameter into the first (i.e., a reducer function).</p>
<p>If there is no need for a transformation, then pass in the
<code><a href="module-xduce.html#.identity">identity</a></code> transducer.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>transducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.TransducerFunction">module:xdcore.TransducerFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A transducer function
that wraps a transducer object whose <code>step</code> function will be used as a
reducer function.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>
|

<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
reducer that knows how to reduce values into an output collection. This
can either be a reducing function or a reducer object whose <code>step</code>
function knows how to perform this reduction.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A reducer function that will transform
elements via the transducer function and then reduce them into whatever
kind of collection the reducer implements.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toReducer"><span class="type-signature">(static) </span>toReducer<span class="signature">(collection)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line194">line 194</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a reducer object from a function or from a reducible type (array,
object, string, or object implementing the reducer protocols).</p>
<p>To create a reducer for arrays, objects, or strings, simply pass an empty
version of that collection to this function (e.g., <code>toReducer([])</code>).</p>
<p>The notable use for this function though is to turn a reduction function into
a reducer object. The function is a function of two parameters, an
accumulator and a value, and returns the accumulator with the value in it.
This is exactly the same kind of function that is passed to reduction
functions like JavaScript's <code>Array.prototype.reduce</code> and Lodash's <code>_.reduce</code>.</p>
<p>Note in particular that the output of this reducer does not need to be a
collection. It can be anything. While transducing normally involves
transforming one collection into another, it need not be so. For example,
here is a reducer that will result in summing of the collection values.</p>
<pre class="prettyprint source"><code>import { toReducer, reduce } from &quot;@chanko/xdcore&quot;;

const sumReducer = toReducer((acc, input) => acc + input);
const sum = reduce([1, 2, 3, 4, 5], sumReducer, 0);
console.log(sum);   // -> 15
</code></pre>
<p>This can be combined with transducers as well, as in this calculation of the
sum of the <em>squares</em> of the collection values.</p>
<pre class="prettyprint source"><code>import { toReducer } from &quot;@chanko/xdcore&quot;;
import { transduce, map } from &quot;@chanko/xduce&quot;;

const sumReducer = toReducer((acc, input) => acc + input);
const sum = transduce([1, 2, 3, 4, 5], map(x => x * x), sumReducer, 0);
console.log(sum);   // -> 55
</code></pre>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>collection</code></td>
            

            <td class="type">
            
                
<span class="param-type">array</span>
|

<span class="param-type">object</span>
|

<span class="param-type">function</span>
|

<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
reducible collection or a reducer function.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An object containing protocol
properties for <code>init</code>, <code>step</code>, and <code>final</code>. This object is suitable for
use as a reducer object (one provided to
<code><a href="module-xdcore.html#.reduce">reduce</a></code>). If the provided collection is not
reducible, all of the properties of this object will be <code>null</code>.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".toTransducer"><span class="type-signature">(static) </span>toTransducer<span class="signature">(fn, reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line255">line 255</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Creates a transducer object from a function and a reducer object.</p>
<p>This is similar to <a href="module-xdcore.html#.toReducer">toReducer</a> except in two
respects:</p>
<ol>
<li>It only accepts a reducer function, not a reducer object</li>
<li>It chains to another reducer object</li>
</ol>
<p>This function applies the given function as the <code>step</code> function of the
returned transducer, and the <code>init</code> and <code>result</code> functions simply call the
same functions in the next reducer object. This is precisely what <em>most</em>
transducers want; <code>init</code> and <code>result</code> functions are normally handled by the
reducer at the end of the transducer chain. In the rare case when an <code>init</code>
or <code>result</code> function must do more than simply chain, this function will not
work. Generally the transducer object is created manually in that case.</p>
<p>This function does not automatically chain the <code>step</code> function to the next
one down the line, as that can be done in any number of different ways. Thus
the function itself should call the <code>step</code> function in <code>reducer</code> in whatever
way is appropriate.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>fn</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>The step function for the transducer.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>The next transducer object in
the chain.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new transducer, chaining the
supplied function to the supplied transducer.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



        
            

    

    <h4 class="name" id=".uncomplete"><span class="type-signature">(static) </span>uncomplete<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line346">line 346</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>Removes the complete status from a completed value.</p>
<p>This function is intended to be used when it's certain that a value is
already marked as complete. If it is not, <code>undefined</code> will be returned
instead of the value.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to be uncompleted.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>An uncompleted version of the provided value. If the value was
not complete in the first place, <code>undefined</code> will be returned instead.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



        
    

    
        <h3 class="subsection-title">Type Definitions</h3>

        
                
<h4 class="name" id=".CompletedValue">CompletedValue</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_reduction.js.html">xdcore/src/modules/reduction.js</a>, <a href="xdcore_src_modules_reduction.js.html#line302">line 302</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>Symbol.for("completed")</code></td>
            

            <td class="type">
            
                
<span class="param-type">boolean</span>


            
            </td>

            

            

            <td class="description last"><p>A marker property to indicate
that this is, in fact, a wrapped completed value.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("value")</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The wrapped value.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>A completed value. This is a wrapper around the actual value, which is
retained as one of the properties, along with a marker property to show that
this is a wrapped value.</p>
</div>








            
                

    

    <h4 class="name" id=".FinalFunction"><span class="type-signature"></span>FinalFunction<span class="signature">(value)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line614">line 614</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a fully reduced collection and returns that
collection with any last-minute modifications that might need to be done to
it.</p>
<p>In most cases this function will simply return its argument, unmodified, but
it does afford the transducer an opportunity to make any final modifications
that might be necessary before the result is returned from the transduction
process.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The fully reduced collection.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The reduced collection with any implementation-dependent changes
that might be deemed necessary.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                

    

    <h4 class="name" id=".InitFunction"><span class="type-signature"></span>InitFunction<span class="signature">()</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line585">line 585</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that, when called, produces a new, empty collection of whatever
type is being worked with.</p>
</div>

























<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new, empty representative of the collection.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                

    

    <h4 class="name" id=".IterableFunction"><span class="type-signature"></span>IterableFunction<span class="signature">(index, last)</span><span class="type-signature"> &rarr; {*}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line569">line 569</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that can have an iterator created for it.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>index</code></td>
            

            <td class="type">
            
                
<span class="param-type">number</span>


            
            </td>

            

            

            <td class="description last"><p>The index for the iteration. This is <code>0</code> the first
time the function is called and increases by 1 for each call
thereafter.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>last</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The return value of the function when it was called on the
previous iteration. If this is the first call to the function, then
this value will be <code>undefined</code>, meaning that the function can set a
default value for that first pass.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The return value of the function, which will be the value for
that iteration.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    



            
                
<h4 class="name" id=".ProtocolMap">ProtocolMap</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_modules_protocol.js.html">xdcore/src/modules/protocol.js</a>, <a href="xdcore_src_modules_protocol.js.html#line17">line 17</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>init</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/init</code> protocol. This is used to mark
functions that initialize a target collection before adding items to it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>step</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/step</code> protocol. This is used to mark
functions that are used in the reducer's step process, where objects are
added to the target collection one at a time.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>final</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/final</code> protocol. This is used to mark
functions that take the final result of the step process and return the
final form to be output. This is optional; if the reducer does not want
to transform the final result, it should just return the result of its
chained reducer's <code>final</code> function.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>reduced</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/completed</code> protocol. The presence of
this key on an object indicates that its transformation has been
completed. It is used internally to mark collections whose
transformations conclude before every object is iterated over (as in
<code>module:xduce.take</code> transducers.) It is of little use beyond
transducer authoring.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">Symbol</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>reducer/value</code> protocol. This is used
internally to mark properties that contain the value of a completed
transformation. It is of little use beyond transducer authoring.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>The mapping of protocol names to their respective property key names. This
mapping makes it easier to deal with these protocols as they can be looked up
by string name rather than by more difficult-to-work-with symbols.</p>
</div>



    <h5>Type:</h5>
    <ul>
        <li>
            
<span class="param-type">object</span>


        </li>
    </ul>






            
                
<h4 class="name" id=".ReducerObject">ReducerObject</h4>





<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line631">line 631</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>



    <h5 class="subsection-title">Properties:</h5>

    

<table class="props">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>Symbol.for("reducer/init")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.InitFunction">module:xdcore.InitFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A function
that can create a new, empty copy of the reducible type.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("reducer/step")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.StepFunction">module:xdcore.StepFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A function
that can accept a value of the reducible type and a new element to be
added to it and return the reducible with the new element incorporated.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>Symbol.for("reducer/final")</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.FinalFunction">module:xdcore.FinalFunction</a></span>


            
            </td>

            

            

            <td class="description last"><p>A
function that accepts a value of the reducible type and returns the same
value with any final modifications that might be necessary for it.</p></td>
        </tr>

    
    </tbody>
</table>






<div class="description usertext">
    <p>An object that provides the information necessary to build and populate a new
object of a reducible type. This information is used by the transduction
engine to create a result from a reduction without having to have its own
type-specific code; the creation, population, and finalization of the result
are delegated instead to this reducer object.</p>
<p>Note that a &quot;transducer object&quot; has exactly the same structure. The only
differences are that the step function in a transducer object modifies the
elements before it reduces them, while a reducer object will not; and a
transducer object will call the equivalent functions in the next object in
the chain, while a reducer object will not. As a corollary, every reducer
object is also a transducer object, but the converse is not true.</p>
</div>








            
                

    

    <h4 class="name" id=".StepFunction"><span class="type-signature"></span>StepFunction<span class="signature">(acc, value)</span><span class="type-signature"></span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line594">line 594</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a collection and a new element of that collection and
returns the collection with the new element added to it. This is used to
build up a new collection (starting with whatever
<a href="module-xdcore.html#.InitFunction">the init function</a> returns) piece by piece
from its elements.</p>
<p>This is in every way a reducer function. The name 'step' comes from the fact
that these reduction functions reduce one element at a time, step by step.</p>
<p>It is up to the implementation whether the returned collection is a modified
form of the original collection or whether it is a new collection altogether.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>acc</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A collection, perhaps with some members already added to it.</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>value</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>A new element to be added to that collection.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The original collection with the new value added to it.</p>
</div>



    



            
                

    

    <h4 class="name" id=".TransducerFunction"><span class="type-signature"></span>TransducerFunction<span class="signature">(reducer)</span><span class="type-signature"> &rarr; {<a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a>}</span></h4>

    




<dl class="details">

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="xdcore_src_index.js.html">xdcore/src/index.js</a>, <a href="xdcore_src_index.js.html#line657">line 657</a>
    </li></ul></dd>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
</dl>





<div class="description usertext">
    <p>A function that accepts a reducer object, which it then chains a transducer
object to. This is the primary way of creating composed transducer chains.</p>
<p>A transducer function basically encapsulates a transducer object and the
ability to chain it to whatever reducer object is passed to it.</p>
</div>











    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>reducer</code></td>
            

            <td class="type">
            
                
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


            
            </td>

            

            

            <td class="description last"><p>The reducer object (which may
also be a transducer object) that is the next reducer in the chain.</p></td>
        </tr>

    
    </tbody>
</table>
















<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A transducer object consisting of some
new transducer object chained to the supplied reducer object.</p>
</div>



<dl class="param-type">
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type"><a href="module-xdcore.html#.ReducerObject">module:xdcore.ReducerObject</a></span>


    </dd>
</dl>

    



            
    

    
</article>

</section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed Apr 01 2020 15:44:13 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>