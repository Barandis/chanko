<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>modules/buffers.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-chanko.html">chanko</a></li><li><a href="module-chanko_buffers.html">chanko/buffers</a></li><li><a href="module-chanko_dispatcher.html">chanko/dispatcher</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-chanko_buffers-DroppingBuffer.html">DroppingBuffer</a><ul class='methods'><li data-type='method'><a href="module-chanko_buffers-DroppingBuffer.html#add">add</a></li><li data-type='method'><a href="module-chanko_buffers-DroppingBuffer.html#remove">remove</a></li></ul></li><li><a href="module-chanko_buffers-FixedBuffer.html">FixedBuffer</a><ul class='methods'><li data-type='method'><a href="module-chanko_buffers-FixedBuffer.html#add">add</a></li><li data-type='method'><a href="module-chanko_buffers-FixedBuffer.html#remove">remove</a></li></ul></li><li><a href="module-chanko_buffers-Queue.html">Queue</a><ul class='methods'><li data-type='method'><a href="module-chanko_buffers-Queue.html#dequeue">dequeue</a></li><li data-type='method'><a href="module-chanko_buffers-Queue.html#enqueue">enqueue</a></li><li data-type='method'><a href="module-chanko_buffers-Queue.html#filter">filter</a></li><li data-type='method'><a href="module-chanko_buffers-Queue.html#peek">peek</a></li></ul></li><li><a href="module-chanko_buffers-SlidingBuffer.html">SlidingBuffer</a><ul class='methods'><li data-type='method'><a href="module-chanko_buffers-SlidingBuffer.html#add">add</a></li><li data-type='method'><a href="module-chanko_buffers-SlidingBuffer.html#remove">remove</a></li></ul></li><li><a href="module-chanko_dispatcher-Dispatcher.html">Dispatcher</a></li><li><a href="module-chanko-Chanko.html">Chanko</a><ul class='methods'></ul></li><li><a href="module-chanko-Chanko.Buffers.html">Buffers</a><ul class='methods'></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/buffers.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Copyright (c) 2020 Thomas J. Otterson
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */

/**
 * Provides several types of buffers usable in buffered channels. These are all
 * built on a small, efficient queue (also provided) which is in turn backed by
 * a JavaScript array.
 *
 * @module chanko/buffers
 */

/**
 * General-purpose buffers that can be used to create buffered channels.
 * 
 * These are all accessed through the `chanko.buffers` object; e.g.
 * `{@link module:chanko/buffers~Buffers.fixed|fixed}` can be called like this:
 * 
 * ```
 * const buffer = chanko.buffers.fixed(3);
 * ```
 * 
 * @namespace Buffers
 * @memberof module:chanko~Chanko
 */

/**
 * A value returned by a buffer when it is empty.
 * 
 * @memberof module:chanko~Chanko
 * @type {Symbol}
 */
const EMPTY = Symbol("EMPTY");

/**
 * A general purpose, highly efficient queue. It's backed by a regular array,
 * but it doesn't use `unshift` to take elements from the array because
 * `unshift` causes elements to be copied each time it's used. Instead, a
 * pointer is maintained that keeps track of the index of the next element to
 * be dequeued, and when that dequeue happens, the pointer simply increments.
 * When the empty space at the head of the array gets large enough, that empty
 * space is removed by a single slice operation.
 *
 * Enqueuing elements is done with a regular `push`, which *is* highly
 * efficient.
 *
 * @namespace Queue
 */

/**
 * Creates a new queue.
 *
 * @returns {module:chanko/buffers~Queue} a new, empty queue.
 * @private
 */
function queue() {
  let store = [];
  let pointer = 0;

  function count() {
    return store.length - pointer;
  }

  function empty() {
    return store.length === 0;
  }

  function enqueue(item) {
    store.push(item);
  }

  function dequeue() {
    if (empty()) {
      return EMPTY;
    }

    const item = store[pointer];
    // This slices off the empty head of the backing store when that empty space
    // is more than half as large as the backing store itself.
    if (++pointer * 2 >= store.length) {
      store = store.slice(pointer);
      pointer = 0;
    }
    return item;
  }

  function peek() {
    return empty() ? EMPTY : store[pointer];
  }

  function filter(fn) {
    for (let i = 0, max = count(); i &lt; max; i++) {
      const item = dequeue();
      if (fn(item)) {
        enqueue(item);
      }
    }
  }

  return Object.freeze({
    /**
     * Returns the number of elements currently stored in the queue. This does
     * not necessarily match the size of the backing store because the pointer
     * may have advanced past some of the items.
     *
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return count();
    },

    /**
     * Indicates whether the queue is empty.
     *
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @type {boolean}
     * @readonly
     */
    get empty() {
      return empty();
    },

    /**
     * Adds a new item to the queue.
     *
     * @function enqueue
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @param {*} item the value being added to the queue.
     */
    enqueue,

    /**
     * Removes the oldest item from the queue and returns that item. If the
     * removal causes the mount of empty space at the head of the backing store
     * to exceed a threshold (half the current count), that empty space is
     * removed.
     *
     * @function dequeue
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @return {*} the oldest item currently stored in the queue.
     */
    dequeue,

    /**
     * Returns the oldest item in the queue without removing it.
     *
     * @function peek
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @return {*} the oldest item currently stored in the queue.
     */
    peek,

    /**
     * Filters out any item in the queue that causes the supplied predicate
     * function to return `false` when passed that item.
     *
     * This is not a typical general-purpose queue operation, but it's useful in
     * this project to filter out inactive handlers in channels.
     *
     * @function filter
     * @memberof module:chanko/buffers~Queue
     * @instance
     * @param {Function} fn the predicate filter function. If an item is passed
     * to this function and the function returns `false`, that item will be
     * removed from the queue.
     */
    filter
  });
}

/**
 * A buffer implementation that never discards buffered items when a new item is
 * added.
 *
 * This buffer has a concept of *full*, but it's a soft limit. If the size of
 * the buffer is exceeded, added items are still stored.
 * {@link module:chanko/buffers~FixedBuffer#full|full} returns `true` any time
 * the size limit is reached or exceeded, so it's entirely possible to call
 * {@link module:chanko/buffers~FixedBuffer#remove|remove} on a full buffer and
 * have it still be full.
 *
 * @namespace FixedBuffer
 */

/**
 * Creates a fixed buffer of the specified capacity.
 *
 * A fixed buffer is a 'normal' buffer, one that stores and returns items on
 * demand. While this buffer can in theory be over-filled, that capability is
 * not used in this project's channels. A buffer that is full will cause the
 * next send to block until an item is received off that channel.
 *
 * This buffer can be passed to `{@link module:chanko~Chanko.chan|chan}` to
 * create a buffered channel.
 *
 * @memberof module:chanko~Chanko.Buffers
 * @param {number} size the number of items that the buffer can hold before it's
 * full.
 * @return {module:chanko/buffers~FixedBuffer} a new fixed buffer of the
 * specified capacity.
 */
function fixed(size) {
  const q = queue();

  return Object.freeze({
    /**
     * The queue that backs this buffer.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @type {module:chanko/buffers~Queue}
     * @readonly
     */
    queue: q,

    /**
     * The size of the buffer.
     *
     * This is *not* the number of elements in the buffer. It is the number of
     * elements that can be stored before the buffer is considered full.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    size,

    /**
     * Indicates whether the buffer as as many or more items stored as its
     * {@link module:chanko/buffers~FixedBuffer#size|size}.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @type {boolean}
     * @readonly
     */
    get full() {
      return q.count >= size;
    },

    /**
     * The number of items currently being stored by the buffer.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return q.count;
    },

    /**
     * Adds one or more items to tbe buffer. These items will be added even if
     * the buffer is full.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @param {...*} items the items to be added to the buffer.
     */
    add(...items) {
      for (const item of items) {
        q.enqueue(item);
      }
    },

    /**
     * Removes and returns the oldest item in the buffer.
     *
     * @memberof module:chanko/buffers~FixedBuffer
     * @instance
     * @return {*} the oldest item in the buffer.
     */
    remove() {
      return q.dequeue();
    }
  });
}

/**
 * A buffer implementation that drops newly added items when the buffer is
 * already full.
 *
 * This dropping action is silent; the new item is simply not added to the
 * buffer. That means this buffer is never 'full' because it can always be added
 * to without exceeding the size, even if that 'adding' doesn't actually result
 * in a new item appearing in the buffer.
 *
 * @namespace DroppingBuffer
 */

/**
 * Creates a dropping buffer of the specified capacity.
 *
 * A dropping buffer silently drops the item being added if the buffer is
 * already at capacity. Since adding a new item will always 'succeed', it is
 * never considered full.
 *
 * This buffer can be passed to `{@link module:chanko~Chanko.chan|chan}` to
 * create a buffered channel.
 *
 * @memberof module:chanko~Chanko.Buffers
 * @param {number} size the number of items the buffer can hold before new items
 * are dropped on add.
 * @return {module:chanko/buffers~DroppingBuffer} a new dropping buffer of the
 * specified capacity.
 */
function dropping(size) {
  const q = queue();

  return Object.freeze({
    /**
     * The queue that backs this buffer.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @type {module:chanko/buffers~Queue}
     * @readonly
     */
    queue: q,

    /**
     * The size of the buffer.
     *
     * This is *not* the number of elements in the buffer. It is the number of
     * elements that can be stored before the buffer is considered full.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    size,

    /**
     * Indicates whether the buffer is full. As this type of buffer is never
     * considered full, this will always be `false`.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @type {boolean}
     * @readonly
     */
    full: false,

    /**
     * The number of items currently being stored by the buffer.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return q.count;
    },

    /**
     * Adds one or more items to tbe buffer. If the buffer is already at
     * capacity, the item will be silently dropped instead.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @param {...*} items the items to be added to the buffer.
     */
    add(...items) {
      for (const item of items) {
        if (q.count &lt; size) {
          q.enqueue(item);
        }
      }
    },

    /**
     * Removes and returns the oldest item in the buffer.
     *
     * @memberof module:chanko/buffers~DroppingBuffer
     * @instance
     * @return {*} the oldest item in the buffer.
     */
    remove() {
      return q.dequeue();
    }
  });
}

/**
 * A buffer implementation that drops the oldest stored item when a new item is
 * added to a full buffer.
 *
 * This action is silent; the oldest item is simply removed before the new one
 * is added. That means this buffer is never 'full' because it can always be
 * added to without exceeding the size, even if that 'adding' also involves
 * removing another item.
 *
 * @namespace SlidingBuffer
 */

/**
 * Creates a sliding buffer of the specified capacity.
 *
 * A sliding buffer drops the oldest item already in the buffer if a new item is
 * added when the buffer is already at capacity. Since it's always capable of
 * having new items added to it, it's never considered full.
 *
 * This buffer can be passed to `{@link module:chanko~Chanko.chan|chan}` to
 * create a buffered channel.
 *
 * @memberof module:chanko~Chanko.Buffers
 * @param {number} size the number of items that the buffer can hold before the
 * oldest items are dropped on add.
 * @return {module:chanko/buffers~SlidingBuffer} a new sliding buffer of the
 * specified capacity.
 */
function sliding(size) {
  const q = queue();

  return Object.freeze({
    /**
     * The queue that backs this buffer.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @type {module:chanko/buffers~Queue}
     * @readonly
     */
    queue: q,

    /**
     * The size of the buffer.
     *
     * This is *not* the number of elements in the buffer. It is the number of
     * elements that can be stored before the buffer is considered full.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    size,

    /**
     * Indicates whether the buffer is full. As this type of buffer is never
     * considered full, this will always be `false`.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @type {boolean}
     * @readonly
     */
    full: false,

    /**
     * The number of items currently being stored by the buffer.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @type {number}
     * @readonly
     */
    get count() {
      return q.count;
    },

    /**
     * Adds one or more items to tbe buffer. If the buffer is already at
     * capacity, the oldest item will be removed before the new one is added.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @param {...*} items the items to be added to the buffer.
     */
    add(...items) {
      for (const item of items) {
        if (q.count === size) {
          q.dequeue();
        }
        q.enqueue(item);
      }
    },

    /**
     * Removes and returns the oldest item in the buffer.
     *
     * @memberof module:chanko/buffers~SlidingBuffer
     * @instance
     * @return {*} the oldest item in the buffer.
     */
    remove() {
      return q.dequeue();
    }
  });
}

export { EMPTY, queue, fixed, dropping, sliding };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
